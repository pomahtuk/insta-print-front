// Generated by CoffeeScript 1.9.3
(function() {
  var GlyphIterator, OpenTypeProcessor, Script,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  GlyphIterator = require('./GlyphIterator');

  Script = require('../layout/Script');

  OpenTypeProcessor = (function() {
    function OpenTypeProcessor(font, table1) {
      this.font = font;
      this.table = table1;
      this.script = null;
      this.scriptTag = null;
      this.language = null;
      this.languageTag = null;
      this.features = {};
      this.lookups = {};
      this.selectScript();
      this.glyphs = [];
      this.positions = [];
      this.ligatureID = 1;
    }

    OpenTypeProcessor.prototype.findScript = function(script) {
      var entry, j, len, ref;
      ref = this.table.scriptList;
      for (j = 0, len = ref.length; j < len; j++) {
        entry = ref[j];
        if (entry.tag === script) {
          return entry;
        }
      }
      return null;
    };

    OpenTypeProcessor.prototype.selectScript = function(script, language) {
      var changed, entry, featureIndex, j, k, l, lang, len, len1, len2, record, ref, ref1, s;
      changed = false;
      if ((this.script == null) || script !== this.scriptTag) {
        if (script != null) {
          if (Array.isArray(script)) {
            for (j = 0, len = script.length; j < len; j++) {
              s = script[j];
              entry = this.findScript(s);
              if (entry) {
                break;
              }
            }
          } else {
            entry = this.findScript(script);
          }
        }
        if (entry == null) {
          entry = this.findScript('DFLT');
        }
        if (entry == null) {
          entry = this.findScript('dflt');
        }
        if (entry == null) {
          entry = this.findScript('latn');
        }
        if (entry == null) {
          return;
        }
        this.scriptTag = entry.tag;
        this.script = entry.script;
        this.direction = Script.direction(script);
        this.language = null;
        changed = true;
      }
      if ((language != null) && language !== this.langugeTag) {
        ref = this.script.langSysRecords;
        for (k = 0, len1 = ref.length; k < len1; k++) {
          lang = ref[k];
          if (!(lang.tag === language)) {
            continue;
          }
          this.language = lang.langSys;
          this.langugeTag = lang.tag;
          changed = true;
          break;
        }
      }
      if (this.language == null) {
        this.language = this.script.defaultLangSys;
      }
      if (changed) {
        this.features = {};
        if (this.language != null) {
          ref1 = this.language.featureIndexes;
          for (l = 0, len2 = ref1.length; l < len2; l++) {
            featureIndex = ref1[l];
            record = this.table.featureList[featureIndex];
            this.features[record.tag] = record.feature;
          }
        }
      }
    };

    OpenTypeProcessor.prototype.lookupsForFeatures = function(userFeatures, exclude) {
      var feature, j, k, len, len1, lookupIndex, lookups, ref, tag;
      if (userFeatures == null) {
        userFeatures = [];
      }
      lookups = [];
      for (j = 0, len = userFeatures.length; j < len; j++) {
        tag = userFeatures[j];
        feature = this.features[tag];
        if (!feature) {
          continue;
        }
        ref = feature.lookupListIndexes;
        for (k = 0, len1 = ref.length; k < len1; k++) {
          lookupIndex = ref[k];
          if (exclude && indexOf.call(exclude, lookupIndex) >= 0) {
            continue;
          }
          lookups.push({
            feature: tag,
            index: lookupIndex,
            lookup: this.table.lookupList.get(lookupIndex)
          });
        }
      }
      lookups.sort(function(a, b) {
        return a.index - b.index;
      });
      return lookups;
    };

    OpenTypeProcessor.prototype.applyFeatures = function(userFeatures, glyphs, advances) {
      var lookups;
      lookups = this.lookupsForFeatures(userFeatures);
      return this.applyLookups(lookups, glyphs, advances);
    };

    OpenTypeProcessor.prototype.applyLookups = function(lookups, glyphs1, positions) {
      var feature, j, k, len, len1, lookup, ref, ref1, res, table;
      this.glyphs = glyphs1;
      this.positions = positions;
      this.glyphIterator = new GlyphIterator(this.glyphs);
      for (j = 0, len = lookups.length; j < len; j++) {
        ref = lookups[j], feature = ref.feature, lookup = ref.lookup;
        this.glyphIterator.reset(lookup.flags);
        while (this.glyphIterator.index < this.glyphs.length) {
          if (!(feature in this.glyphIterator.cur.features)) {
            this.glyphIterator.index++;
            continue;
          }
          ref1 = lookup.subTables;
          for (k = 0, len1 = ref1.length; k < len1; k++) {
            table = ref1[k];
            res = this.applyLookup(lookup.lookupType, table);
            if (res) {
              break;
            }
          }
          this.glyphIterator.index++;
        }
      }
    };

    OpenTypeProcessor.prototype.applyLookup = function(lookup, table) {
      throw new Error("applyLookup must be implemented by subclasses");
    };

    OpenTypeProcessor.prototype.applyLookupList = function(lookupRecords) {
      var glyphIndex, j, k, len, len1, lookup, lookupRecord, ref, table;
      glyphIndex = this.glyphIterator.index;
      for (j = 0, len = lookupRecords.length; j < len; j++) {
        lookupRecord = lookupRecords[j];
        this.glyphIterator.index = glyphIndex + lookupRecord.sequenceIndex;
        lookup = this.table.lookupList.get(lookupRecord.lookupListIndex);
        ref = lookup.subTables;
        for (k = 0, len1 = ref.length; k < len1; k++) {
          table = ref[k];
          this.applyLookup(lookup.lookupType, table);
        }
      }
      this.glyphIterator.index = glyphIndex;
    };

    OpenTypeProcessor.prototype.coverageIndex = function(coverage, glyph) {
      var i, j, len, range, ref;
      if (glyph == null) {
        glyph = this.glyphIterator.cur.id;
      }
      switch (coverage.version) {
        case 1:
          return coverage.glyphs.indexOf(glyph);
        case 2:
          ref = coverage.rangeRecords;
          for (i = j = 0, len = ref.length; j < len; i = ++j) {
            range = ref[i];
            if ((range.start <= glyph && glyph <= range.end)) {
              return range.startCoverageIndex + glyph - range.start;
            }
          }
      }
      return -1;
    };

    OpenTypeProcessor.prototype.match = function(sequenceIndex, sequence, fn, matched) {
      var glyph, idx, pos;
      pos = this.glyphIterator.index;
      glyph = this.glyphIterator.increment(sequenceIndex);
      idx = 0;
      while (idx < sequence.length && glyph && fn(sequence[idx], glyph.id)) {
        if (matched != null) {
          matched.push(this.glyphIterator.index);
        }
        idx++;
        glyph = this.glyphIterator.next();
      }
      this.glyphIterator.index = pos;
      if (idx < sequence.length) {
        return false;
      }
      return matched || true;
    };

    OpenTypeProcessor.prototype.sequenceMatches = function(sequenceIndex, sequence) {
      return this.match(sequenceIndex, sequence, function(component, glyph) {
        return component === glyph;
      });
    };

    OpenTypeProcessor.prototype.sequenceMatchIndices = function(sequenceIndex, sequence) {
      return this.match(sequenceIndex, sequence, function(component, glyph) {
        return component === glyph;
      }, []);
    };

    OpenTypeProcessor.prototype.coverageSequenceMatches = function(sequenceIndex, sequence) {
      return this.match(sequenceIndex, sequence, (function(_this) {
        return function(coverage, glyph) {
          return _this.coverageIndex(coverage, glyph) >= 0;
        };
      })(this));
    };

    OpenTypeProcessor.prototype.getClassID = function(glyph, classDef) {
      var classID, glyphID, j, k, len, len1, range, ref, ref1;
      switch (classDef.version) {
        case 1:
          glyphID = classDef.startGlyph;
          ref = classDef.classValueArray;
          for (j = 0, len = ref.length; j < len; j++) {
            classID = ref[j];
            if (glyph === glyphID++) {
              return classID;
            }
          }
          break;
        case 2:
          ref1 = classDef.classRangeRecord;
          for (k = 0, len1 = ref1.length; k < len1; k++) {
            range = ref1[k];
            if ((range.start <= glyph && glyph <= range.end)) {
              return range["class"];
            }
          }
      }
      return -1;
    };

    OpenTypeProcessor.prototype.classSequenceMatches = function(sequenceIndex, sequence, classDef) {
      return this.match(sequenceIndex, sequence, (function(_this) {
        return function(classID, glyph) {
          return classID === _this.getClassID(glyph, classDef);
        };
      })(this));
    };

    OpenTypeProcessor.prototype.applyContext = function(table) {
      var index, j, k, len, len1, rule, set;
      switch (table.version) {
        case 1:
          index = this.coverageIndex(table.coverage);
          if (index === -1) {
            return;
          }
          set = table.ruleSets[index];
          for (j = 0, len = set.length; j < len; j++) {
            rule = set[j];
            if (this.sequenceMatches(1, rule.input)) {
              return this.applyLookupList(rule.lookupRecords);
            }
          }
          break;
        case 2:
          if (this.coverageIndex(table.coverage) === -1) {
            return;
          }
          index = this.getClassID(this.glyphIterator.cur.id, table.classDef);
          if (index === -1) {
            return;
          }
          set = table.classSet[index];
          for (k = 0, len1 = set.length; k < len1; k++) {
            rule = set[k];
            if (this.classSequenceMatches(1, rule.classes, table.classDef)) {
              return this.applyLookupList(rule.lookupRecords);
            }
          }
          break;
        case 3:
          if (this.coverageSequenceMatches(0, table.coverages)) {
            return this.applyLookupList(table.lookupRecords);
          }
      }
    };

    OpenTypeProcessor.prototype.applyChainingContext = function(table) {
      var index, j, k, len, len1, rule, rules, set;
      switch (table.version) {
        case 1:
          index = this.coverageIndex(table.coverage);
          if (index === -1) {
            return;
          }
          set = table.chainRuleSets[index];
          for (j = 0, len = set.length; j < len; j++) {
            rule = set[j];
            if (this.sequenceMatches(-rule.backtrack.length, rule.backtrack) && this.sequenceMatches(1, rule.input) && this.sequenceMatches(1 + rule.input.length, rule.lookahead)) {
              return this.applyLookupList(rule.lookupRecords);
            }
          }
          break;
        case 2:
          if (this.coverageIndex(table.coverage) === -1) {
            return;
          }
          index = this.getClassID(this.glyphIterator.cur.id, table.inputClassDef);
          if (index === -1) {
            return;
          }
          rules = table.chainClassSet[index];
          for (k = 0, len1 = rules.length; k < len1; k++) {
            rule = rules[k];
            if (this.classSequenceMatches(-rule.backtrack.length, rule.backtrack, table.backtrackClassDef) && this.classSequenceMatches(1, rule.input, table.inputClassDef) && this.classSequenceMatches(1 + rule.input.length, rule.lookahead, table.lookaheadClassDef)) {
              return this.applyLookupList(rule.lookupRecords);
            }
          }
          break;
        case 3:
          if (this.coverageSequenceMatches(-table.backtrackGlyphCount, table.backtrackCoverage) && this.coverageSequenceMatches(0, table.inputCoverage) && this.coverageSequenceMatches(table.inputGlyphCount, table.lookaheadCoverage)) {
            return this.applyLookupList(table.lookupRecords);
          }
      }
    };

    return OpenTypeProcessor;

  })();

  module.exports = OpenTypeProcessor;

}).call(this);
