// Generated by CoffeeScript 1.9.3
(function() {
  var DefaultShaper, GlyphInfo, HangulShaper,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  DefaultShaper = require('./DefaultShaper');

  GlyphInfo = require('../GlyphInfo');

  HangulShaper = (function(superClass) {
    var COMPOSE, DECOMPOSE, DOTTED_CIRCLE, HANGUL_BASE, HANGUL_COUNT, HANGUL_END, INVALID, L, LV, LVT, L_BASE, L_COUNT, L_END, M, NO_ACTION, STATE_TABLE, T, TONE_MARK, T_BASE, T_COUNT, T_END, V, V_BASE, V_COUNT, V_END, X, compose, decompose, getGlyph, getType, insertDottedCircle, isCombiningL, isCombiningT, isCombiningV, isL, isLV, isLVT, isT, isTone, isV, reorderToneMark;

    extend(HangulShaper, superClass);

    function HangulShaper() {
      return HangulShaper.__super__.constructor.apply(this, arguments);
    }

    HANGUL_BASE = 0xac00;

    HANGUL_END = 0xd7a4;

    HANGUL_COUNT = HANGUL_END - HANGUL_BASE + 1;

    L_BASE = 0x1100;

    V_BASE = 0x1161;

    T_BASE = 0x11a7;

    L_COUNT = 19;

    V_COUNT = 21;

    T_COUNT = 28;

    L_END = L_BASE + L_COUNT - 1;

    V_END = V_BASE + V_COUNT - 1;

    T_END = T_BASE + T_COUNT - 1;

    DOTTED_CIRCLE = 0x25cc;

    isL = function(code) {
      return (0x1100 <= code && code <= 0x115f) || (0xa960 <= code && code <= 0xa97c);
    };

    isV = function(code) {
      return (0x1160 <= code && code <= 0x11a7) || (0xd7b0 <= code && code <= 0xd7c6);
    };

    isT = function(code) {
      return (0x11a8 <= code && code <= 0x11ff) || (0xd7cb <= code && code <= 0xd7fb);
    };

    isTone = function(code) {
      return (0x302e <= code && code <= 0x302f);
    };

    isLVT = function(code) {
      return (HANGUL_BASE <= code && code <= HANGUL_END);
    };

    isLV = function(c) {
      c -= HANGUL_BASE;
      return c < HANGUL_COUNT && c % T_COUNT === 0;
    };

    isCombiningL = function(code) {
      return (L_BASE <= code && code <= L_END);
    };

    isCombiningV = function(code) {
      return (V_BASE <= code && code <= V_END);
    };

    isCombiningT = function(code) {
      return (T_BASE + 1 <= code && code <= T_END);
    };

    X = 0;

    L = 1;

    V = 2;

    T = 3;

    LV = 4;

    LVT = 5;

    M = 6;

    getType = function(code) {
      if (isL(code)) {
        return L;
      }
      if (isV(code)) {
        return V;
      }
      if (isT(code)) {
        return T;
      }
      if (isLV(code)) {
        return LV;
      }
      if (isLVT(code)) {
        return LVT;
      }
      if (isTone(code)) {
        return M;
      }
      return X;
    };

    NO_ACTION = 0;

    DECOMPOSE = 1;

    COMPOSE = 2;

    TONE_MARK = 4;

    INVALID = 5;

    STATE_TABLE = [[[NO_ACTION, 0], [NO_ACTION, 1], [NO_ACTION, 0], [NO_ACTION, 0], [DECOMPOSE, 2], [DECOMPOSE, 3], [INVALID, 0]], [[NO_ACTION, 0], [NO_ACTION, 1], [COMPOSE, 2], [NO_ACTION, 0], [DECOMPOSE, 2], [DECOMPOSE, 3], [INVALID, 0]], [[NO_ACTION, 0], [NO_ACTION, 1], [NO_ACTION, 0], [COMPOSE, 3], [DECOMPOSE, 2], [DECOMPOSE, 3], [TONE_MARK, 0]], [[NO_ACTION, 0], [NO_ACTION, 1], [NO_ACTION, 0], [NO_ACTION, 0], [DECOMPOSE, 2], [DECOMPOSE, 3], [TONE_MARK, 0]]];

    HangulShaper.assignFeatures = function(glyphs, script, font) {
      var action, code, glyph, i, ref, state, type;
      state = 0;
      i = 0;
      while (i < glyphs.length) {
        glyph = glyphs[i];
        code = glyph.codePoints[0];
        type = getType(code);
        ref = STATE_TABLE[state][type], action = ref[0], state = ref[1];
        switch (action) {
          case DECOMPOSE:
            if (!font.hasGlyphForCodePoint(code)) {
              i = decompose(glyphs, i, font);
            }
            break;
          case COMPOSE:
            i = compose(glyphs, i, font);
            break;
          case TONE_MARK:
            reorderToneMark(glyphs, i, font);
            break;
          case INVALID:
            i = insertDottedCircle(glyphs, i, font);
        }
        i++;
      }
      return ['ljmo', 'vjmo', 'tjmo'];
    };

    getGlyph = function(font, code, features) {
      return new GlyphInfo(font.glyphForCodePoint(code).id, [code], Object.keys(features));
    };

    decompose = function(glyphs, i, font) {
      var code, glyph, insert, l, ljmo, s, t, tjmo, v, vjmo;
      glyph = glyphs[i];
      code = glyph.codePoints[0];
      s = code - HANGUL_BASE;
      t = T_BASE + s % T_COUNT;
      s = s / T_COUNT | 0;
      l = L_BASE + s / V_COUNT | 0;
      v = V_BASE + s % V_COUNT;
      if (!(font.hasGlyphForCodePoint(l) && font.hasGlyphForCodePoint(v) && (t === T_BASE || font.hasGlyphForCodePoint(t)))) {
        return i;
      }
      ljmo = getGlyph(font, l, glyph.features);
      ljmo.features.ljmo = true;
      vjmo = getGlyph(font, v, glyph.features);
      vjmo.features.vjmo = true;
      insert = [ljmo, vjmo];
      if (t > T_BASE) {
        tjmo = getGlyph(font, t, glyph.features);
        tjmo.features.tjmo = true;
        insert.push(tjmo);
      }
      glyphs.splice.apply(glyphs, [i, 1].concat(slice.call(insert)));
      return i + insert.length - 1;
    };

    compose = function(glyphs, i, font) {
      var code, del, glyph, l, ljmo, lv, prev, prevType, s, t, tjmo, type, v, vjmo;
      glyph = glyphs[i];
      code = glyphs[i].codePoints[0];
      type = getType(code);
      prev = glyphs[i - 1].codePoints[0];
      prevType = getType(prev);
      if (prevType === LV && type === T) {
        lv = prev;
        tjmo = glyph;
      } else {
        if (type === V) {
          ljmo = glyphs[i - 1];
          vjmo = glyph;
        } else {
          ljmo = glyphs[i - 2];
          vjmo = glyphs[i - 1];
          tjmo = glyph;
        }
        l = ljmo.codePoints[0];
        v = vjmo.codePoints[0];
        if (isCombiningL(l) && isCombiningV(v)) {
          lv = HANGUL_BASE + ((l - L_BASE) * V_COUNT + (v - V_BASE)) * T_COUNT;
        }
      }
      t = (tjmo != null ? tjmo.codePoints[0] : void 0) || T_BASE;
      if ((lv != null) && (t === T_BASE || isCombiningT(t))) {
        s = lv + (t - T_BASE);
        if (font.hasGlyphForCodePoint(s)) {
          del = prevType === V ? 3 : 2;
          glyphs.splice(i - del + 1, del, getGlyph(font, s, glyph.features));
          return i - del + 1;
        }
      }
      if (ljmo != null) {
        ljmo.features.ljmo = true;
      }
      if (vjmo != null) {
        vjmo.features.vjmo = true;
      }
      if (tjmo != null) {
        tjmo.features.tjmo = true;
      }
      if (prevType === LV) {
        decompose(glyphs, i - 1, font);
        return i + 1;
      }
      return i;
    };

    reorderToneMark = function(glyphs, i, font) {
      var code, glyph, len, prev;
      glyph = glyphs[i];
      code = glyphs[i].codePoints[0];
      if (font.glyphForCodePoint(code).advanceWidth === 0) {
        return;
      }
      prev = glyphs[i - 1].codePoints[0];
      len = (function() {
        switch (getType(prev)) {
          case LV:
          case LVT:
            return 1;
          case V:
            return 2;
          case T:
            return 3;
        }
      })();
      glyphs.splice(i, 1);
      return glyphs.splice(i - len, 0, glyph);
    };

    insertDottedCircle = function(glyphs, i, font) {
      var code, dottedCircle, glyph, idx;
      glyph = glyphs[i];
      code = glyphs[i].codePoints[0];
      if (font.hasGlyphForCodePoint(DOTTED_CIRCLE)) {
        dottedCircle = getGlyph(font, DOTTED_CIRCLE, glyph.features);
        idx = font.glyphForCodePoint(code).advanceWidth === 0 ? i : i + 1;
        glyphs.splice(idx, 0, dottedCircle);
        i++;
      }
      return i;
    };

    return HangulShaper;

  })(DefaultShaper);

  module.exports = HangulShaper;

}).call(this);
