// Generated by CoffeeScript 1.9.3
(function() {
  var AATLookupTable, AATMorxProcessor, AATStateMachine,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    slice = [].slice;

  AATStateMachine = require('./AATStateMachine');

  AATLookupTable = require('./AATLookupTable');

  AATMorxProcessor = (function() {
    var CURRENT_INSERT_BEFORE, CURRENT_INSERT_COUNT, CURRENT_IS_KASHIDA_LIKE, HORIZONTAL_AND_VERTICAL, LAST_MASK, MARKED_INSERT_BEFORE, MARKED_INSERT_COUNT, MARKED_IS_KASHIDA_LIKE, MARK_FIRST, MARK_LAST, OFFSET_MASK, PERFORM_ACTION, REVERSE_DIRECTION, SET_COMPONENT, SET_MARK, STORE_MASK, VERB, VERTICAL_ONLY, reorderGlyphs, swap;

    MARK_FIRST = 0x8000;

    MARK_LAST = 0x2000;

    VERB = 0x000F;

    SET_MARK = 0x8000;

    SET_COMPONENT = 0x8000;

    PERFORM_ACTION = 0x2000;

    LAST_MASK = 0x80000000;

    STORE_MASK = 0x40000000;

    OFFSET_MASK = 0x3FFFFFFF;

    VERTICAL_ONLY = 0x800000;

    REVERSE_DIRECTION = 0x400000;

    HORIZONTAL_AND_VERTICAL = 0x200000;

    CURRENT_IS_KASHIDA_LIKE = 0x2000;

    MARKED_IS_KASHIDA_LIKE = 0x1000;

    CURRENT_INSERT_BEFORE = 0x0800;

    MARKED_INSERT_BEFORE = 0x0400;

    CURRENT_INSERT_COUNT = 0x03E0;

    MARKED_INSERT_COUNT = 0x001F;

    function AATMorxProcessor(font) {
      this.font = font;
      this.processGlyphInsertion = bind(this.processGlyphInsertion, this);
      this.processNoncontextualSubstitutions = bind(this.processNoncontextualSubstitutions, this);
      this.processLigature = bind(this.processLigature, this);
      this.processContextualSubstitution = bind(this.processContextualSubstitution, this);
      this.processIndicRearragement = bind(this.processIndicRearragement, this);
      this.morx = this.font.morx;
    }

    AATMorxProcessor.prototype.process = function(glyphs, features) {
      var chain, f, feature, flags, i, index, j, k, len, len1, len2, ref, ref1, ref2, subtable;
      if (features == null) {
        features = {};
      }
      ref = this.morx.chains;
      for (i = 0, len = ref.length; i < len; i++) {
        chain = ref[i];
        flags = chain.defaultFlags;
        ref1 = chain.features;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          feature = ref1[j];
          if ((f = features[feature.featureType]) && f[feature.featureSetting]) {
            flags &= feature.disableFlags;
            flags |= feature.enableFlags;
          }
        }
        ref2 = chain.subtables;
        for (index = k = 0, len2 = ref2.length; k < len2; index = ++k) {
          subtable = ref2[index];
          if (subtable.subFeatureFlags & flags) {
            this.processSubtable(subtable, glyphs);
          }
        }
      }
      index = glyphs.length - 1;
      while (index >= 0) {
        if (glyphs[index].id === 0xffff) {
          glyphs.splice(index, 1);
        }
        index--;
      }
      return glyphs;
    };

    AATMorxProcessor.prototype.processSubtable = function(subtable1, glyphs1) {
      var process, reverse, stateMachine;
      this.subtable = subtable1;
      this.glyphs = glyphs1;
      if (this.subtable.type === 4) {
        this.processNoncontextualSubstitutions(this.subtable, this.glyphs);
        return;
      }
      this.ligatureStack = [];
      this.markedGlyph = null;
      this.firstGlyph = null;
      this.lastGlyph = null;
      this.markedIndex = null;
      stateMachine = new AATStateMachine(this.subtable.table.stateTable);
      process = (function() {
        switch (this.subtable.type) {
          case 0:
            return this.processIndicRearragement;
          case 1:
            return this.processContextualSubstitution;
          case 2:
            return this.processLigature;
          case 5:
            return this.processGlyphInsertion;
          default:
            throw new Error("Invalid morx subtable type: " + this.subtable.type);
        }
      }).call(this);
      reverse = !!(this.subtable.coverage & REVERSE_DIRECTION);
      return stateMachine.process(this.glyphs, reverse, process);
    };

    AATMorxProcessor.prototype.processIndicRearragement = function(glyph, entry, index) {
      if (entry.flags & MARK_FIRST) {
        this.firstGlyph = index;
      }
      if (entry.flags & MARK_LAST) {
        this.lastGlyph = index;
      }
      reorderGlyphs(this.glyphs, entry.flags & VERB, this.firstGlyph, this.lastGlyph);
    };

    swap = function(glyphs, rangeA, rangeB, reverseA, reverseB) {
      var end, start;
      if (reverseA == null) {
        reverseA = false;
      }
      if (reverseB == null) {
        reverseB = false;
      }
      end = glyphs.splice(rangeB[0] - (rangeB[1] - 1), rangeB[1]);
      if (reverseB) {
        end.reverse();
      }
      start = glyphs.splice.apply(glyphs, [rangeA[0], rangeA[1]].concat(slice.call(end)));
      if (reverseA) {
        start.reverse();
      }
      return glyphs.splice.apply(glyphs, [rangeB[0] - (rangeA[1] - 1), 0].concat(slice.call(start)));
    };

    reorderGlyphs = function(glyphs, verb, firstGlyph, lastGlyph) {
      var length;
      length = lastGlyph - firstGlyph + 1;
      switch (verb) {
        case 0:
          break;
        case 1:
          swap(glyphs, [firstGlyph, 1], [lastGlyph, 0]);
          break;
        case 2:
          swap(glyphs, [firstGlyph, 0], [lastGlyph, 1]);
          break;
        case 3:
          swap(glyphs, [firstGlyph, 1], [lastGlyph, 1]);
          break;
        case 4:
          swap(glyphs, [firstGlyph, 2], [lastGlyph, 0]);
          break;
        case 5:
          swap(glyphs, [firstGlyph, 2], [lastGlyph, 0], true, false);
          break;
        case 6:
          swap(glyphs, [firstGlyph, 0], [lastGlyph, 2]);
          break;
        case 7:
          swap(glyphs, [firstGlyph, 0], [lastGlyph, 2], false, true);
          break;
        case 8:
          swap(glyphs, [firstGlyph, 1], [lastGlyph, 2]);
          break;
        case 9:
          swap(glyphs, [firstGlyph, 1], [lastGlyph, 2], false, true);
          break;
        case 10:
          swap(glyphs, [firstGlyph, 2], [lastGlyph, 1]);
          break;
        case 11:
          swap(glyphs, [firstGlyph, 2], [lastGlyph, 1], true, false);
          break;
        case 12:
          swap(glyphs, [firstGlyph, 2], [lastGlyph, 2]);
          break;
        case 13:
          swap(glyphs, [firstGlyph, 2], [lastGlyph, 2], true, false);
          break;
        case 14:
          swap(glyphs, [firstGlyph, 2], [lastGlyph, 2], false, true);
          break;
        case 15:
          swap(glyphs, [firstGlyph, 2], [lastGlyph, 2], true, true);
          break;
        default:
          throw new Error("Unknown verb: " + verb);
      }
      return glyphs;
    };

    AATMorxProcessor.prototype.processContextualSubstitution = function(glyph, entry, index) {
      var gid, lookup, lookupTable, subsitutions;
      subsitutions = this.subtable.table.substitutionTable.items;
      if (entry.markIndex !== 0xffff) {
        lookup = subsitutions.getItem(entry.markIndex);
        lookupTable = new AATLookupTable(lookup);
        glyph = this.glyphs[this.markedGlyph];
        gid = lookupTable.lookup(glyph.id);
        if (gid) {
          this.glyphs[this.markedGlyph] = this.font.getGlyph(gid, glyph.codePoints);
        }
      }
      if (entry.currentIndex !== 0xffff) {
        lookup = subsitutions.getItem(entry.currentIndex);
        lookupTable = new AATLookupTable(lookup);
        glyph = this.glyphs[index];
        gid = lookupTable.lookup(glyph.id);
        if (gid) {
          this.glyphs[index] = this.font.getGlyph(gid, glyph.codePoints);
        }
      }
      if (entry.flags & SET_MARK) {
        this.markedGlyph = index;
      }
    };

    AATMorxProcessor.prototype.processLigature = function(glyph, entry, index) {
      var action, actionIndex, actions, codePoints, component, componentGlyph, components, last, ligatureEntry, ligatureIndex, ligatureList, offset, store;
      if (entry.flags & SET_COMPONENT) {
        this.ligatureStack.push(index);
      }
      if (entry.flags & PERFORM_ACTION) {
        actions = this.subtable.table.ligatureActions;
        components = this.subtable.table.components;
        ligatureList = this.subtable.table.ligatureList;
        actionIndex = entry.action;
        last = false;
        ligatureIndex = 0;
        codePoints = [];
        while (!last) {
          componentGlyph = this.ligatureStack.pop();
          codePoints.unshift.apply(codePoints, this.glyphs[componentGlyph].codePoints);
          action = actions.getItem(actionIndex++);
          last = !!(action & LAST_MASK);
          store = !!(action & STORE_MASK);
          offset = (action & OFFSET_MASK) << 2 >> 2;
          offset += this.glyphs[componentGlyph].id;
          component = components.getItem(offset);
          ligatureIndex += component;
          if (last || store) {
            ligatureEntry = ligatureList.getItem(ligatureIndex);
            this.glyphs[componentGlyph] = this.font.getGlyph(ligatureEntry, codePoints);
            ligatureIndex = 0;
            codePoints = [];
          } else {
            this.glyphs[componentGlyph] = this.font.getGlyph(0xffff);
          }
        }
      }
    };

    AATMorxProcessor.prototype.processNoncontextualSubstitutions = function(subtable, glyphs, index) {
      var gid, glyph, i, len, lookupTable;
      lookupTable = new AATLookupTable(subtable.table.lookupTable);
      for (index = i = 0, len = glyphs.length; i < len; index = ++i) {
        glyph = glyphs[index];
        if (!(glyph.id !== 0xffff)) {
          continue;
        }
        gid = lookupTable.lookup(glyph.id);
        if (gid) {
          glyphs[index] = this.font.getGlyph(gid, glyph.codePoints);
        }
      }
    };

    AATMorxProcessor.prototype._insertGlyphs = function(glyphIndex, insertionActionIndex, count, isBefore) {
      var gid, insertions, ref;
      insertions = (function() {
        var results;
        results = [];
        while (count--) {
          gid = this.subtable.table.insertionActions.getItem(insertionActionIndex++);
          results.push(this.font.getGlyph(gid));
        }
        return results;
      }).call(this);
      if (!isBefore) {
        glyphIndex++;
      }
      (ref = this.glyphs).splice.apply(ref, [glyphIndex, 0].concat(slice.call(insertions)));
    };

    AATMorxProcessor.prototype.processGlyphInsertion = function(glyph, entry, index) {
      var count, isBefore;
      if (entry.flags & SET_MARK) {
        this.markedIndex = index;
      }
      if (entry.markedInsertIndex !== 0xffff) {
        count = (entry.flags & MARKED_INSERT_COUNT) >>> 5;
        isBefore = !!(entry.flags & MARKED_INSERT_BEFORE);
        this._insertGlyphs(this.markedIndex, entry.markedInsertIndex, count, isBefore);
      }
      if (entry.currentInsertIndex !== 0xffff) {
        count = (entry.flags & CURRENT_INSERT_COUNT) >>> 5;
        isBefore = !!(entry.flags & CURRENT_INSERT_BEFORE);
        this._insertGlyphs(index, entry.currentInsertIndex, count, isBefore);
      }
    };

    AATMorxProcessor.prototype.getSupportedFeatures = function() {
      var chain, feature, features, i, j, len, len1, ref, ref1;
      features = [];
      ref = this.morx.chains;
      for (i = 0, len = ref.length; i < len; i++) {
        chain = ref[i];
        ref1 = chain.features;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          feature = ref1[j];
          features.push([feature.featureType, feature.featureSetting]);
        }
      }
      return features;
    };

    return AATMorxProcessor;

  })();

  module.exports = AATMorxProcessor;

}).call(this);
