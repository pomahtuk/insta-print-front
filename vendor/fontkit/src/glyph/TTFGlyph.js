// Generated by CoffeeScript 1.9.3
(function() {
  var BBox, Glyph, Path, TTFGlyph, r,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Glyph = require('./Glyph');

  Path = require('./Path');

  BBox = require('./BBox');

  r = require('restructure');

  TTFGlyph = (function(superClass) {
    var ARGS_ARE_XY_VALUES, ARG_1_AND_2_ARE_WORDS, Component, GlyfHeader, MORE_COMPONENTS, ON_CURVE, OVERLAP_COMPOUND, Point, REPEAT, ROUND_XY_TO_GRID, SAME_X, SAME_Y, SCALED_COMPONENT_OFFSET, UNSCALED_COMPONENT_OFFSET, USE_MY_METRICS, WE_HAVE_AN_X_AND_Y_SCALE, WE_HAVE_A_SCALE, WE_HAVE_A_TWO_BY_TWO, WE_HAVE_INSTRUCTIONS, X_SHORT_VECTOR, Y_SHORT_VECTOR, parseGlyphCoord;

    extend(TTFGlyph, superClass);

    function TTFGlyph() {
      return TTFGlyph.__super__.constructor.apply(this, arguments);
    }

    GlyfHeader = new r.Struct({
      numberOfContours: r.int16,
      xMin: r.int16,
      yMin: r.int16,
      xMax: r.int16,
      yMax: r.int16
    });

    ON_CURVE = 1 << 0;

    X_SHORT_VECTOR = 1 << 1;

    Y_SHORT_VECTOR = 1 << 2;

    REPEAT = 1 << 3;

    SAME_X = 1 << 4;

    SAME_Y = 1 << 5;

    ARG_1_AND_2_ARE_WORDS = 1 << 0;

    ARGS_ARE_XY_VALUES = 1 << 1;

    ROUND_XY_TO_GRID = 1 << 2;

    WE_HAVE_A_SCALE = 1 << 3;

    MORE_COMPONENTS = 1 << 5;

    WE_HAVE_AN_X_AND_Y_SCALE = 1 << 6;

    WE_HAVE_A_TWO_BY_TWO = 1 << 7;

    WE_HAVE_INSTRUCTIONS = 1 << 8;

    USE_MY_METRICS = 1 << 9;

    OVERLAP_COMPOUND = 1 << 10;

    SCALED_COMPONENT_OFFSET = 1 << 11;

    UNSCALED_COMPONENT_OFFSET = 1 << 12;

    Point = (function() {
      function Point(onCurve, endContour, x, y) {
        this.onCurve = onCurve;
        this.endContour = endContour;
        this.x = x != null ? x : 0;
        this.y = y != null ? y : 0;
      }

      Point.prototype.copy = function() {
        return new Point(this.onCurve, this.endContour, this.x, this.y);
      };

      return Point;

    })();

    Component = (function() {
      function Component(glyphID1, dx1, dy1) {
        this.glyphID = glyphID1;
        this.dx = dx1;
        this.dy = dy1;
        this.pos = 0;
        this.scale = this.xScale = this.yScale = this.scale01 = this.scale10 = null;
      }

      return Component;

    })();

    TTFGlyph.prototype._getCBox = function(internal) {
      var cbox, glyph, stream;
      if (this._font._variationProcessor && !internal) {
        return this.path.cbox;
      }
      stream = this._font._getTableStream('glyf');
      stream.pos += this._font.loca.offsets[this.id];
      glyph = GlyfHeader.decode(stream);
      cbox = new BBox(glyph.xMin, glyph.yMin, glyph.xMax, glyph.yMax);
      return Object.freeze(cbox);
    };

    parseGlyphCoord = function(stream, prev, short, same) {
      var val;
      if (short) {
        val = stream.readUInt8();
        if (!same) {
          val = -val;
        }
        val += prev;
      } else {
        if (same) {
          val = prev;
        } else {
          val = prev + stream.readInt16BE();
        }
      }
      return val;
    };

    TTFGlyph.prototype._decode = function() {
      var glyfPos, glyph, nextPos, startPos, stream;
      glyfPos = this._font.loca.offsets[this.id];
      nextPos = this._font.loca.offsets[this.id + 1];
      if (glyfPos === nextPos) {
        return null;
      }
      stream = this._font._getTableStream('glyf');
      stream.pos += glyfPos;
      startPos = stream.pos;
      glyph = GlyfHeader.decode(stream);
      if (glyph.numberOfContours > 0) {
        this._decodeSimple(glyph, stream);
      } else if (glyph.numberOfContours < 0) {
        this._decodeComposite(glyph, stream, startPos);
      }
      return glyph;
    };

    TTFGlyph.prototype._decodeSimple = function(glyph, stream) {
      var count, endPtsOfContours, flag, flags, i, instructions, j, k, l, len, len1, len2, m, n, numCoords, point, points, px, py, ref;
      glyph.points = [];
      endPtsOfContours = new r.Array(r.uint16, glyph.numberOfContours).decode(stream);
      instructions = new r.Array(r.uint8, r.uint16).decode(stream);
      flags = [];
      numCoords = endPtsOfContours[endPtsOfContours.length - 1] + 1;
      while (flags.length < numCoords) {
        flag = stream.readUInt8();
        flags.push(flag);
        if (flag & REPEAT) {
          count = stream.readUInt8();
          for (j = k = 0, ref = count; k < ref; j = k += 1) {
            flags.push(flag);
          }
        }
      }
      for (i = l = 0, len = flags.length; l < len; i = ++l) {
        flag = flags[i];
        point = new Point(!!(flag & ON_CURVE), endPtsOfContours.indexOf(i) >= 0, 0, 0);
        glyph.points.push(point);
      }
      px = 0;
      for (i = m = 0, len1 = flags.length; m < len1; i = ++m) {
        flag = flags[i];
        glyph.points[i].x = px = parseGlyphCoord(stream, px, flag & X_SHORT_VECTOR, flag & SAME_X);
      }
      py = 0;
      for (i = n = 0, len2 = flags.length; n < len2; i = ++n) {
        flag = flags[i];
        glyph.points[i].y = py = parseGlyphCoord(stream, py, flag & Y_SHORT_VECTOR, flag & SAME_Y);
      }
      if (this._font._variationProcessor) {
        points = glyph.points.slice();
        points.push.apply(points, this._getPhantomPoints(glyph));
        this._font._variationProcessor.transformPoints(this.id, points);
        glyph.phantomPoints = points.slice(-4);
      }
    };

    TTFGlyph.prototype._decodeComposite = function(glyph, stream, offset) {
      var component, dx, dy, flags, gPos, glyphID, haveInstructions, i, k, len, point, points;
      if (offset == null) {
        offset = 0;
      }
      glyph.components = [];
      haveInstructions = false;
      flags = MORE_COMPONENTS;
      while (flags & MORE_COMPONENTS) {
        flags = stream.readUInt16BE();
        gPos = stream.pos - offset;
        glyphID = stream.readUInt16BE();
        haveInstructions || (haveInstructions = (flags & WE_HAVE_INSTRUCTIONS) !== 0);
        if (flags & ARG_1_AND_2_ARE_WORDS) {
          dx = stream.readInt16BE();
          dy = stream.readInt16BE();
        } else {
          dx = stream.readInt8();
          dy = stream.readInt8();
        }
        component = new Component(glyphID, dx, dy);
        component.pos = gPos;
        component.scaleX = component.scaleY = 1;
        component.scale01 = component.scale10 = 0;
        if (flags & WE_HAVE_A_SCALE) {
          component.scaleX = component.scaleY = ((stream.readUInt8() << 24) | (stream.readUInt8() << 16)) / 1073741824;
        } else if (flags & WE_HAVE_AN_X_AND_Y_SCALE) {
          component.scaleX = ((stream.readUInt8() << 24) | (stream.readUInt8() << 16)) / 1073741824;
          component.scaleY = ((stream.readUInt8() << 24) | (stream.readUInt8() << 16)) / 1073741824;
        } else if (flags & WE_HAVE_A_TWO_BY_TWO) {
          component.scaleX = ((stream.readUInt8() << 24) | (stream.readUInt8() << 16)) / 1073741824;
          component.scale01 = ((stream.readUInt8() << 24) | (stream.readUInt8() << 16)) / 1073741824;
          component.scale10 = ((stream.readUInt8() << 24) | (stream.readUInt8() << 16)) / 1073741824;
          component.scaleY = ((stream.readUInt8() << 24) | (stream.readUInt8() << 16)) / 1073741824;
        }
        glyph.components.push(component);
      }
      if (this._font._variationProcessor) {
        points = (function() {
          var k, len, ref, results;
          ref = glyph.components;
          results = [];
          for (k = 0, len = ref.length; k < len; k++) {
            component = ref[k];
            results.push(new Point(true, true, component.dx, component.dy));
          }
          return results;
        })();
        points.push.apply(points, this._getPhantomPoints(glyph));
        this._font._variationProcessor.transformPoints(this.id, points);
        glyph.phantomPoints = points.splice(-4, 4);
        for (i = k = 0, len = points.length; k < len; i = ++k) {
          point = points[i];
          glyph.components[i].dx = point.x;
          glyph.components[i].dy = point.y;
        }
      }
      return haveInstructions;
    };

    TTFGlyph.prototype._getPhantomPoints = function(glyph) {
      var advanceHeight, advanceWidth, cbox, leftBearing, ref, topBearing;
      cbox = this._getCBox(true);
      if (this._metrics == null) {
        this._metrics = Glyph.prototype._getMetrics.call(this, cbox);
      }
      ref = this._metrics, advanceWidth = ref.advanceWidth, advanceHeight = ref.advanceHeight, leftBearing = ref.leftBearing, topBearing = ref.topBearing;
      return [new Point(false, true, glyph.xMin - leftBearing, 0), new Point(false, true, glyph.xMin - leftBearing + advanceWidth, 0), new Point(false, true, 0, glyph.yMax + topBearing), new Point(false, true, 0, glyph.yMax + topBearing + advanceHeight)];
    };

    TTFGlyph.prototype._getContours = function() {
      var component, contours, cur, glyph, k, l, len, len1, len2, m, point, points, ref, ref1;
      glyph = this._decode();
      if (!glyph) {
        return [];
      }
      if (glyph.numberOfContours < 0) {
        points = [];
        ref = glyph.components;
        for (k = 0, len = ref.length; k < len; k++) {
          component = ref[k];
          glyph = this._font.getGlyph(component.glyphID)._decode();
          ref1 = glyph.points;
          for (l = 0, len1 = ref1.length; l < len1; l++) {
            point = ref1[l];
            points.push(new Point(point.onCurve, point.endContour, point.x + component.dx, point.y + component.dy));
          }
        }
      } else {
        points = glyph.points;
      }
      if (glyph.phantomPoints) {
        this._metrics.advanceWidth = glyph.phantomPoints[1].x - glyph.phantomPoints[0].x;
        this._metrics.advanceHeight = glyph.phantomPoints[3].y - glyph.phantomPoints[2].y;
        this._metrics.leftBearing = glyph.xMin - glyph.phantomPoints[0].x;
        this._metrics.topBearing = glyph.phantomPoints[2].y - glyph.yMax;
      }
      contours = [];
      cur = [];
      for (m = 0, len2 = points.length; m < len2; m++) {
        point = points[m];
        cur.push(point);
        if (point.endContour) {
          contours.push(cur);
          cur = [];
        }
      }
      return contours;
    };

    TTFGlyph.prototype._getMetrics = function() {
      var cbox;
      if (this._metrics) {
        return this._metrics;
      }
      cbox = this._getCBox(true);
      TTFGlyph.__super__._getMetrics.call(this, cbox);
      if (this._font._variationProcessor) {
        if (this._path == null) {
          this._path = this._getPath();
        }
      }
      return this._metrics;
    };

    TTFGlyph.prototype._getPath = function() {
      var contour, contours, curvePt, firstPt, j, k, l, lastPt, len, midX, midY, path, prevPt, pt, ref, ref1, start;
      contours = this._getContours();
      path = new Path;
      for (k = 0, len = contours.length; k < len; k++) {
        contour = contours[k];
        firstPt = contour[0];
        lastPt = contour[contour.length - 1];
        start = 0;
        if (firstPt.onCurve) {
          curvePt = null;
          start = 1;
        } else {
          if (lastPt.onCurve) {
            firstPt = lastPt;
          } else {
            firstPt = new Point(false, false, (firstPt.x + lastPt.x) / 2, (firstPt.y + lastPt.y) / 2);
          }
          curvePt = firstPt;
        }
        path.moveTo(firstPt.x, firstPt.y);
        for (j = l = ref = start, ref1 = contour.length; l < ref1; j = l += 1) {
          pt = contour[j];
          prevPt = j === 0 ? firstPt : contour[j - 1];
          if (prevPt.onCurve && pt.onCurve) {
            path.lineTo(pt.x, pt.y);
          } else if (prevPt.onCurve && !pt.onCurve) {
            curvePt = pt;
          } else if (!prevPt.onCurve && !pt.onCurve) {
            midX = (prevPt.x + pt.x) / 2;
            midY = (prevPt.y + pt.y) / 2;
            path.quadraticCurveTo(prevPt.x, prevPt.y, midX, midY);
            curvePt = pt;
          } else if (!prevPt.onCurve && pt.onCurve) {
            path.quadraticCurveTo(curvePt.x, curvePt.y, pt.x, pt.y);
            curvePt = null;
          } else {
            throw new Error("Unknown TTF path state");
          }
        }
        if (firstPt !== lastPt) {
          if (curvePt) {
            path.quadraticCurveTo(curvePt.x, curvePt.y, firstPt.x, firstPt.y);
          } else {
            path.lineTo(firstPt.x, firstPt.y);
          }
        }
      }
      path.closePath();
      return path;
    };

    return TTFGlyph;

  })(Glyph);

  module.exports = TTFGlyph;

}).call(this);
