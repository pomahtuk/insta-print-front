// Generated by CoffeeScript 1.9.3
(function() {
  var CFFGlyph, Glyph, Path,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Glyph = require('./Glyph');

  Path = require('./Path');

  CFFGlyph = (function(superClass) {
    var bias;

    extend(CFFGlyph, superClass);

    function CFFGlyph() {
      return CFFGlyph.__super__.constructor.apply(this, arguments);
    }

    bias = function(s) {
      if (s.length < 1240) {
        return 107;
      } else if (s.length < 33900) {
        return 1131;
      } else {
        return 32768;
      }
    };

    CFFGlyph.prototype._getPath = function() {
      var cff, end, gsubrs, gsubrsBias, nStems, parse, parseStems, path, pos, privateDict, stack, str, stream, subrs, subrsBias, trans, usedGsubrs, usedSubrs, width, x, y;
      stream = this._font.stream;
      pos = stream.pos;
      cff = this._font['CFF '];
      str = cff.topDict.CharStrings[this.id];
      end = str.offset + str.length;
      stream.pos = str.offset;
      path = new Path;
      stack = [];
      trans = [];
      width = null;
      nStems = 0;
      x = y = 0;
      this._usedGsubrs = usedGsubrs = {};
      this._usedSubrs = usedSubrs = {};
      gsubrs = cff.globalSubrIndex || [];
      gsubrsBias = bias(gsubrs);
      privateDict = cff.privateDictForGlyph(this.id);
      subrs = privateDict.Subrs || [];
      subrsBias = bias(subrs);
      parseStems = function() {
        if (stack.length % 2 !== 0) {
          if (width == null) {
            width = stack.shift() + privateDict.nominalWidthX;
          }
        }
        nStems += stack.length >> 1;
        return stack.length = 0;
      };
      (parse = function() {
        var a, b, b1, c1x, c1y, c2x, c2y, c3x, c3y, c4x, c4y, c5x, c5y, c6x, c6y, e, haveWidth, i, idx, index, j, k, l, m, n, o, op, p, phase, pts, ref, ref1, s1, s2, startx, starty, subr, t, v1, v2, val;
        while (stream.pos < end) {
          op = stream.readUInt8();
          if (op < 32) {
            switch (op) {
              case 1:
              case 3:
              case 18:
              case 23:
                parseStems();
                break;
              case 4:
                if (stack.length > 1) {
                  if (width == null) {
                    width = stack.shift() + privateDict.nominalWidthX;
                  }
                }
                y += stack.shift();
                path.moveTo(x, y);
                break;
              case 5:
                while (stack.length >= 2) {
                  x += stack.shift();
                  y += stack.shift();
                  path.lineTo(x, y);
                }
                break;
              case 6:
              case 7:
                phase = op === 6;
                while (stack.length >= 1) {
                  if (phase) {
                    x += stack.shift();
                  } else {
                    y += stack.shift();
                  }
                  path.lineTo(x, y);
                  phase = !phase;
                }
                break;
              case 8:
                while (stack.length > 0) {
                  c1x = x + stack.shift();
                  c1y = y + stack.shift();
                  c2x = c1x + stack.shift();
                  c2y = c1y + stack.shift();
                  x = c2x + stack.shift();
                  y = c2y + stack.shift();
                  path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
                }
                break;
              case 10:
                index = stack.pop() + subrsBias;
                subr = subrs[index];
                if (subr) {
                  usedSubrs[index] = true;
                  p = stream.pos;
                  e = end;
                  stream.pos = subr.offset;
                  end = subr.offset + subr.length;
                  parse();
                  stream.pos = p;
                  end = e;
                }
                break;
              case 11:
                return;
              case 14:
                if (stack.length > 0) {
                  if (width == null) {
                    width = stack.shift() + privateDict.nominalWidthX;
                  }
                }
                path.closePath();
                break;
              case 19:
              case 20:
                parseStems();
                stream.pos += (nStems + 7) >> 3;
                break;
              case 21:
                if (stack.length > 2) {
                  if (width == null) {
                    width = stack.shift() + privateDict.nominalWidthX;
                  }
                  haveWidth = true;
                }
                x += stack.shift();
                y += stack.shift();
                path.moveTo(x, y);
                break;
              case 22:
                if (stack.length > 1) {
                  if (width == null) {
                    width = stack.shift() + privateDict.nominalWidthX;
                  }
                }
                x += stack.shift();
                path.moveTo(x, y);
                break;
              case 24:
                while (stack.length >= 8) {
                  c1x = x + stack.shift();
                  c1y = y + stack.shift();
                  c2x = c1x + stack.shift();
                  c2y = c1y + stack.shift();
                  x = c2x + stack.shift();
                  y = c2y + stack.shift();
                  path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
                }
                x += stack.shift();
                y += stack.shift();
                path.lineTo(x, y);
                break;
              case 25:
                while (stack.length >= 8) {
                  x += stack.shift();
                  y += stack.shift();
                  path.lineTo(x, y);
                }
                c1x = x + stack.shift();
                c1y = y + stack.shift();
                c2x = c1x + stack.shift();
                c2y = c1y + stack.shift();
                x = c2x + stack.shift();
                y = c2y + stack.shift();
                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
                break;
              case 26:
                if (stack.length % 2) {
                  x += stack.shift();
                }
                while (stack.length >= 4) {
                  c1x = x;
                  c1y = y + stack.shift();
                  c2x = c1x + stack.shift();
                  c2y = c1y + stack.shift();
                  x = c2x;
                  y = c2y + stack.shift();
                  path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
                }
                break;
              case 27:
                if (stack.length % 2) {
                  y += stack.shift();
                }
                while (stack.length >= 4) {
                  c1x = x + stack.shift();
                  c1y = y;
                  c2x = c1x + stack.shift();
                  c2y = c1y + stack.shift();
                  x = c2x + stack.shift();
                  y = c2y;
                  path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
                }
                break;
              case 28:
                stack.push(stream.readInt16BE());
                break;
              case 29:
                index = stack.pop() + gsubrsBias;
                subr = gsubrs[index];
                if (subr) {
                  usedGsubrs[index] = true;
                  p = stream.pos;
                  e = end;
                  stream.pos = subr.offset;
                  end = subr.offset + subr.length;
                  parse();
                  stream.pos = p;
                  end = e;
                }
                break;
              case 30:
              case 31:
                phase = op === 31;
                while (stack.length >= 4) {
                  if (phase) {
                    c1x = x + stack.shift();
                    c1y = y;
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    y = c2y + stack.shift();
                    x = c2x + (stack.length === 1 ? stack.shift() : 0);
                  } else {
                    c1x = x;
                    c1y = y + stack.shift();
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    x = c2x + stack.shift();
                    y = c2y + (stack.length === 1 ? stack.shift() : 0);
                  }
                  path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
                  phase = !phase;
                }
                break;
              case 12:
                op = stream.readUInt8();
                switch (op) {
                  case 3:
                    a = stack.pop();
                    b = stack.pop();
                    stack.push(a && b ? 1 : 0);
                    break;
                  case 4:
                    a = stack.pop();
                    b = stack.pop();
                    stack.push(a || b ? 1 : 0);
                    break;
                  case 5:
                    a = stack.pop();
                    stack.push(a ? 0 : 1);
                    break;
                  case 9:
                    a = stack.pop();
                    stack.push(Math.abs(a));
                    break;
                  case 10:
                    a = stack.pop();
                    b = stack.pop();
                    stack.push(a + b);
                    break;
                  case 11:
                    a = stack.pop();
                    b = stack.pop();
                    stack.push(a - b);
                    break;
                  case 12:
                    a = stack.pop();
                    b = stack.pop();
                    stack.push(a / b);
                    break;
                  case 14:
                    a = stack.pop();
                    stack.push(-a);
                    break;
                  case 15:
                    a = stack.pop();
                    b = stack.pop();
                    stack.push(a === b ? 1 : 0);
                    break;
                  case 18:
                    stack.pop();
                    break;
                  case 20:
                    val = stack.pop();
                    idx = stack.pop();
                    trans[idx] = val;
                    break;
                  case 21:
                    idx = stack.pop();
                    stack.push(trans[idx] || 0);
                    break;
                  case 22:
                    s1 = stack.pop();
                    s2 = stack.pop();
                    v1 = stack.pop();
                    v2 = stack.pop();
                    stack.push(v1 <= v2 ? s1 : s2);
                    break;
                  case 23:
                    stack.push(Math.random());
                    break;
                  case 24:
                    a = stack.pop();
                    b = stack.pop();
                    stack.push(a * b);
                    break;
                  case 26:
                    a = stack.pop();
                    stack.push(Math.sqrt(a));
                    break;
                  case 27:
                    a = stack.pop();
                    stack.push(a, a);
                    break;
                  case 28:
                    a = stack.pop();
                    b = stack.pop();
                    stack.push(b, a);
                    break;
                  case 29:
                    idx = stack.pop();
                    if (idx < 0) {
                      idx = 0;
                    } else if (idx > stack.length - 1) {
                      idx = stack.length - 1;
                    }
                    stack.push(stack[idx]);
                    break;
                  case 30:
                    n = stack.pop();
                    j = stack.pop();
                    if (j >= 0) {
                      while (j > 0) {
                        t = stack[n - 1];
                        for (i = k = ref = n - 2; k >= 0; i = k += -1) {
                          stack[i + 1] = stack[i];
                        }
                        stack[0] = t;
                        j--;
                      }
                    } else {
                      while (j < 0) {
                        t = stack[0];
                        for (i = l = 0, ref1 = n; l <= ref1; i = l += 1) {
                          stack[i] = stack[i + 1];
                        }
                        stack[n - 1] = t;
                        j++;
                      }
                    }
                    break;
                  case 34:
                    c1x = x + stack.shift();
                    c1y = y;
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    c3x = c2x + stack.shift();
                    c3y = c2y;
                    c4x = c3x + stack.shift();
                    c4y = c3y;
                    c5x = c4x + stack.shift();
                    c5y = c4y;
                    c6x = c5x + stack.shift();
                    c6y = c5y;
                    x = c6x;
                    y = c6y;
                    path.bezierCurveTo(c1x, c1y, c2x, c2y, c3x, c3y);
                    path.bezierCurveTo(c4x, c4y, c5x, c5y, c6x, c6y);
                    break;
                  case 35:
                    pts = [];
                    for (i = m = 0; m < 6; i = ++m) {
                      x += stack.shift();
                      y += stack.shift();
                      pts.push(x, y);
                    }
                    path.bezierCurveTo.apply(path, pts.slice(0, 6));
                    path.bezierCurveTo.apply(path, pts.slice(6));
                    stack.shift();
                    break;
                  case 36:
                    c1x = x + stack.shift();
                    c1y = y + stack.shift();
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    c3x = c2x + stack.shift();
                    c3y = c2y;
                    c4x = c3x + stack.shift();
                    c4y = c3y;
                    c5x = c4x + stack.shift();
                    c5y = c4y + stack.shift();
                    c6x = c5x + stack.shift();
                    c6y = c5y;
                    x = c6x;
                    y = c6y;
                    path.bezierCurveTo(c1x, c1y, c2x, c2y, c3x, c3y);
                    path.bezierCurveTo(c4x, c4y, c5x, c5y, c6x, c6y);
                    break;
                  case 37:
                    startx = x;
                    starty = y;
                    pts = [];
                    for (i = o = 0; o < 5; i = ++o) {
                      x += stack.shift();
                      y += stack.shift();
                      pts.push(x, y);
                    }
                    if (Math.abs(x - startx) > Math.abs(y - starty)) {
                      x += stack.shift();
                      y = starty;
                    } else {
                      x = startx;
                      y += stack.shift();
                    }
                    pts.push(x, y);
                    path.bezierCurveTo.apply(path, pts.slice(0, 6));
                    path.bezierCurveTo.apply(path, pts.slice(6));
                    break;
                  default:
                    throw new Error('Unknown op: 12 ' + op);
                }
                break;
              default:
                throw new Error('Unknown op: ' + op);
            }
          } else if (op < 247) {
            stack.push(op - 139);
          } else if (op < 251) {
            b1 = stream.readUInt8();
            stack.push((op - 247) * 256 + b1 + 108);
          } else if (op < 255) {
            b1 = stream.readUInt8();
            stack.push(-(op - 251) * 256 - b1 - 108);
          } else {
            stack.push(stream.readInt32BE() / 65536);
          }
        }
      })();
      return path;
    };

    return CFFGlyph;

  })(Glyph);

  module.exports = CFFGlyph;

}).call(this);
