// Generated by CoffeeScript 1.9.3
(function() {
  var GlyphVariationProcessor;

  GlyphVariationProcessor = (function() {
    var DELTAS_ARE_WORDS, DELTAS_ARE_ZERO, DELTA_RUN_COUNT_MASK, EMBEDDED_TUPLE_COORD, INTERMEDIATE_TUPLE, POINTS_ARE_WORDS, POINT_RUN_COUNT_MASK, PRIVATE_POINT_NUMBERS, TUPLES_SHARE_POINT_NUMBERS, TUPLE_COUNT_MASK, TUPLE_INDEX_MASK;

    function GlyphVariationProcessor(font, coords) {
      this.font = font;
      this.normalizedCoords = this.normalizeCoords(coords);
    }

    TUPLES_SHARE_POINT_NUMBERS = 0x8000;

    TUPLE_COUNT_MASK = 0x0fff;

    EMBEDDED_TUPLE_COORD = 0x8000;

    INTERMEDIATE_TUPLE = 0x4000;

    PRIVATE_POINT_NUMBERS = 0x2000;

    TUPLE_INDEX_MASK = 0x0fff;

    POINTS_ARE_WORDS = 0x80;

    POINT_RUN_COUNT_MASK = 0x7f;

    DELTAS_ARE_ZERO = 0x80;

    DELTAS_ARE_WORDS = 0x40;

    DELTA_RUN_COUNT_MASK = 0x3f;

    GlyphVariationProcessor.prototype.normalizeCoords = function(coords) {
      var axis, i, j, l, len, len1, m, normalized, pair, prev, ref3, ref4, segment;
      normalized = (function() {
        var l, len, ref3, results;
        ref3 = this.font.fvar.axis;
        results = [];
        for (i = l = 0, len = ref3.length; l < len; i = ++l) {
          axis = ref3[i];
          if (coords[i] < axis.defaultValue) {
            results.push((coords[i] - axis.defaultValue) / (axis.defaultValue - axis.minValue));
          } else {
            results.push((coords[i] - axis.defaultValue) / (axis.maxValue - axis.defaultValue));
          }
        }
        return results;
      }).call(this);
      if (this.font.avar) {
        ref3 = this.font.avar.segment;
        for (i = l = 0, len = ref3.length; l < len; i = ++l) {
          segment = ref3[i];
          ref4 = segment.correspondence;
          for (j = m = 0, len1 = ref4.length; m < len1; j = ++m) {
            pair = ref4[j];
            if (j >= 1 && normalized[i] < pair.fromCoord) {
              prev = segment.correspondence[j - 1];
              normalized[i] = (normalized[i] - prev.fromCoord) * (pair.toCoord - prev.toCoord) / (pair.fromCoord - prev.fromCoord) + prev.toCoord;
              break;
            }
          }
        }
      }
      return normalized;
    };

    GlyphVariationProcessor.prototype.transformPoints = function(gid, glyphPoints) {
      var a, endCoords, factor, gvar, hasDelta, here, i, idx, l, len, len1, m, n, nPoints, offset, offsetToData, origPoints, p, point, points, ref3, sharedPoints, startCoords, stream, tupleCoords, tupleCount, tupleDataSize, tupleIndex, xDeltas, yDeltas;
      if (!(this.font.fvar && this.font.gvar)) {
        return;
      }
      gvar = this.font.gvar;
      if (gid >= gvar.glyphCount) {
        return;
      }
      offset = gvar.offsets[gid];
      if (offset === gvar.offsets[gid + 1]) {
        return;
      }
      stream = this.font.stream;
      stream.pos = offset;
      tupleCount = stream.readUInt16BE();
      offsetToData = offset + stream.readUInt16BE();
      if (tupleCount & TUPLES_SHARE_POINT_NUMBERS) {
        here = stream.pos;
        stream.pos = offsetToData;
        sharedPoints = this.decodePoints();
        stream.pos = here;
      }
      for (i = l = 0, ref3 = tupleCount & TUPLE_COUNT_MASK; l < ref3; i = l += 1) {
        tupleDataSize = stream.readUInt16BE();
        tupleIndex = stream.readUInt16BE();
        if (tupleIndex & EMBEDDED_TUPLE_COORD) {
          tupleCoords = (function() {
            var m, ref4, results;
            results = [];
            for (a = m = 0, ref4 = gvar.axisCount; m < ref4; a = m += 1) {
              results.push(stream.readInt16BE() / 16384);
            }
            return results;
          })();
        } else {
          if ((tupleIndex & TUPLE_INDEX_MASK) >= gvar.globalCoordCount) {
            throw new Error('Invalid gvar table');
          }
          tupleCoords = gvar.globalCoords[tupleIndex & TUPLE_INDEX_MASK];
        }
        if (tupleIndex & INTERMEDIATE_TUPLE) {
          startCoords = (function() {
            var m, ref4, results;
            results = [];
            for (a = m = 0, ref4 = gvar.axisCount; m < ref4; a = m += 1) {
              results.push(stream.readInt16BE() / 16384);
            }
            return results;
          })();
          endCoords = (function() {
            var m, ref4, results;
            results = [];
            for (a = m = 0, ref4 = gvar.axisCount; m < ref4; a = m += 1) {
              results.push(stream.readInt16BE() / 16384);
            }
            return results;
          })();
        }
        factor = this.tupleFactor(tupleIndex, tupleCoords, startCoords, endCoords);
        if (factor === 0) {
          offsetToData += tupleDataSize;
          continue;
        }
        here = stream.pos;
        if (tupleIndex & PRIVATE_POINT_NUMBERS) {
          stream.pos = offsetToData;
          points = this.decodePoints();
        } else {
          points = sharedPoints;
        }
        nPoints = points.length === 0 ? glyphPoints.length : points.length;
        xDeltas = this.decodeDeltas(nPoints);
        yDeltas = this.decodeDeltas(nPoints);
        if (points.length === 0) {
          for (i = m = 0, len = glyphPoints.length; m < len; i = ++m) {
            point = glyphPoints[i];
            point.x += xDeltas[i] * factor;
            point.y += yDeltas[i] * factor;
          }
        } else {
          origPoints = glyphPoints.slice();
          hasDelta = (function() {
            var len1, n, results;
            results = [];
            for (n = 0, len1 = glyphPoints.length; n < len1; n++) {
              p = glyphPoints[n];
              results.push(false);
            }
            return results;
          })();
          for (i = n = 0, len1 = points.length; n < len1; i = ++n) {
            idx = points[i];
            if (!(idx < glyphPoints.length)) {
              continue;
            }
            point = glyphPoints[idx];
            origPoints[idx] = point.copy();
            hasDelta[idx] = true;
            point.x += xDeltas[i] * factor;
            point.y += yDeltas[i] * factor;
          }
          this.interpolateMissingDeltas(glyphPoints, origPoints, hasDelta);
        }
        offsetToData += tupleDataSize;
        stream.pos = here;
      }
    };

    GlyphVariationProcessor.prototype.decodePoints = function() {
      var count, fn, i, j, l, point, points, ref3, run, runCount, stream;
      stream = this.font.stream;
      count = stream.readUInt8();
      if (count & POINTS_ARE_WORDS) {
        count = (count & POINT_RUN_COUNT_MASK) << 8 | stream.readUInt8();
      }
      points = new Uint16Array(count);
      i = 0;
      while (i < count) {
        run = stream.readUInt8();
        runCount = (run & POINT_RUN_COUNT_MASK) + 1;
        if (i + runCount > count) {
          throw new Error('Bad point run length');
        }
        fn = run & POINTS_ARE_WORDS ? stream.readUInt16 : stream.readUInt8;
        point = 0;
        for (j = l = 0, ref3 = runCount; l < ref3; j = l += 1) {
          point += fn.call(stream);
          points[i++] = point;
        }
      }
      return points;
    };

    GlyphVariationProcessor.prototype.decodeDeltas = function(count) {
      var deltas, fn, i, j, l, ref3, run, runCount, stream;
      stream = this.font.stream;
      i = 0;
      deltas = new Int16Array(count);
      while (i < count) {
        run = stream.readUInt8();
        runCount = (run & DELTA_RUN_COUNT_MASK) + 1;
        if (i + runCount > count) {
          throw new Error('Bad delta run length');
        }
        if (run & DELTAS_ARE_ZERO) {
          i += runCount;
        } else {
          fn = run & DELTAS_ARE_WORDS ? stream.readInt16BE : stream.readInt8;
          for (j = l = 0, ref3 = runCount; l < ref3; j = l += 1) {
            deltas[i++] = fn.call(stream);
          }
        }
      }
      return deltas;
    };

    GlyphVariationProcessor.prototype.tupleFactor = function(tupleIndex, tupleCoords, startCoords, endCoords) {
      var factor, gvar, i, l, normalized, ref3;
      normalized = this.normalizedCoords;
      gvar = this.font.gvar;
      factor = 1;
      for (i = l = 0, ref3 = gvar.axisCount; l < ref3; i = l += 1) {
        if (tupleCoords[i] === 0) {
          continue;
        } else if (normalized[i] === 0) {
          return 0;
        } else if ((normalized[i] < 0 && tupleCoords[i] > 0) || (normalized[i] > 0 && tupleCoords[i] < 0)) {
          return 0;
        } else if ((tupleIndex & INTERMEDIATE_TUPLE) === 0) {
          factor *= Math.abs(normalized[i]);
        } else if ((normalized[i] < startCoords[i]) || (normalized[i] > endCoords[i])) {
          return 0;
        } else if (normalized[i] < tupleCoords[i]) {
          factor = (factor * (normalized[i] - startCoords[i])) / (tupleCoords[i] - startCoords[i]);
        } else {
          factor = factor * (endCoords[i] - normalized[i]) / (endCoords[i] - tupleCoords[i]);
        }
      }
      return factor;
    };

    GlyphVariationProcessor.prototype.interpolateMissingDeltas = function(points, inPoints, hasDelta) {
      var curDelta, endPoint, firstDelta, firstPoint, point, pt;
      if (points.length === 0) {
        return;
      }
      point = 0;
      while (point < points.length) {
        firstPoint = point;
        endPoint = point;
        pt = points[endPoint];
        while (!pt.endContour) {
          pt = points[++endPoint];
        }
        while (point <= endPoint && !hasDelta[point]) {
          point++;
        }
        if (!(point <= endPoint)) {
          continue;
        }
        firstDelta = point;
        curDelta = point;
        point++;
        while (point <= endPoint) {
          if (hasDelta[point]) {
            this.deltaInterpolate(curDelta + 1, point - 1, curDelta, point, inPoints, points);
            curDelta = point;
          }
          point++;
        }
        if (curDelta === firstDelta) {
          this.deltaShift(firstPoint, endPoint, curDelta, inPoints, points);
        } else {
          this.deltaInterpolate(curDelta + 1, endPoint, curDelta, firstDelta, inPoints, points);
          if (firstDelta > 0) {
            this.deltaInterpolate(firstPoint, firstDelta - 1, curDelta, firstDelta, inPoints, points);
          }
        }
        point = endPoint + 1;
      }
    };

    GlyphVariationProcessor.prototype.deltaInterpolate = function(p1, p2, ref1, ref2, inPoints, outPoints) {
      var in1, in2, k, l, len, m, out, out1, out2, p, ref3, ref4, ref5, scale;
      if (p1 > p2) {
        return;
      }
      ref3 = ['x', 'y'];
      for (l = 0, len = ref3.length; l < len; l++) {
        k = ref3[l];
        if (inPoints[ref1][k] > inPoints[ref2][k]) {
          p = ref1;
          ref1 = ref2;
          ref2 = p;
        }
        in1 = inPoints[ref1][k];
        in2 = inPoints[ref2][k];
        out1 = outPoints[ref1][k];
        out2 = outPoints[ref2][k];
        scale = in1 === in2 ? 0 : (out2 - out1) / (in2 - in1);
        for (p = m = ref4 = p1, ref5 = p2; m <= ref5; p = m += 1) {
          out = inPoints[p][k];
          if (out <= in1) {
            out += out1 - in1;
          } else if (out >= in2) {
            out += out2 - in2;
          } else {
            out = out1 + (out - in1) * scale;
          }
          outPoints[p][k] = out;
        }
      }
    };

    GlyphVariationProcessor.prototype.deltaShift = function(p1, p2, ref, inPoints, outPoints) {
      var deltaX, deltaY, l, p, ref3, ref4;
      deltaX = outPoints[ref].x - inPoints[ref].x;
      deltaY = outPoints[ref].y - inPoints[ref].y;
      if (deltaX === 0 && deltaY === 0) {
        return;
      }
      for (p = l = ref3 = p1, ref4 = p2; l <= ref4; p = l += 1) {
        if (!(p !== ref)) {
          continue;
        }
        outPoints[p].x += deltaX;
        outPoints[p].y += deltaY;
      }
    };

    return GlyphVariationProcessor;

  })();

  module.exports = GlyphVariationProcessor;

}).call(this);
