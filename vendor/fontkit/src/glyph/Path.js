// Generated by CoffeeScript 1.9.3
(function() {
  var BBox, Path,
    slice = [].slice;

  BBox = require('./BBox');

  Path = (function() {
    var SVG_COMMANDS, command, fn, get, j, len, ref;

    get = require('../get')(Path);

    function Path() {
      this.commands = [];
      this._bbox = this._cbox = null;
    }

    ref = ['moveTo', 'lineTo', 'quadraticCurveTo', 'bezierCurveTo', 'closePath'];
    fn = function(command) {
      return Path.prototype[command] = function() {
        var args;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        this._bbox = this._cbox = null;
        this.commands.push({
          command: command,
          args: args
        });
        return this;
      };
    };
    for (j = 0, len = ref.length; j < len; j++) {
      command = ref[j];
      fn(command);
    }

    Path.prototype.toFunction = function() {
      var c, cmds, k, len1, ref1;
      cmds = [];
      ref1 = this.commands;
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        c = ref1[k];
        cmds.push("  ctx." + c.command + "(" + (c.args.join(', ')) + ");");
      }
      return new Function('ctx', cmds.join('\n'));
    };

    SVG_COMMANDS = {
      moveTo: 'M',
      lineTo: 'L',
      quadraticCurveTo: 'Q',
      bezierCurveTo: 'C',
      closePath: 'Z'
    };

    Path.prototype.toSVG = function() {
      var arg, args, c, cmds, k, len1, ref1;
      cmds = [];
      ref1 = this.commands;
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        c = ref1[k];
        args = (function() {
          var l, len2, ref2, results;
          ref2 = c.args;
          results = [];
          for (l = 0, len2 = ref2.length; l < len2; l++) {
            arg = ref2[l];
            results.push(Math.round(arg * 100) / 100);
          }
          return results;
        })();
        cmds.push("" + SVG_COMMANDS[c.command] + (args.join(' ')));
      }
      return cmds.join('');
    };

    get('cbox', function() {
      var cbox, i, k, l, len1, len2, ref1, ref2, x;
      if (this._cbox) {
        return this._cbox;
      }
      cbox = new BBox;
      ref1 = this.commands;
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        command = ref1[k];
        ref2 = command.args;
        for (i = l = 0, len2 = ref2.length; l < len2; i = l += 2) {
          x = ref2[i];
          cbox.addPoint(x, command.args[i + 1]);
        }
      }
      return this._cbox = Object.freeze(cbox);
    });

    get('bbox', function() {
      var a, b, b2ac, bbox, c, cp1x, cp1y, cp2x, cp2y, cx, cy, f, i, k, l, len1, p0, p1, p2, p3, p3x, p3y, qp1x, qp1y, ref1, ref2, ref3, ref4, t, t1, t2, x, y;
      if (this._bbox) {
        return this._bbox;
      }
      bbox = new BBox;
      cx = cy = 0;
      f = function(t) {
        return Math.pow(1 - t, 3) * p0[i] + 3 * Math.pow(1 - t, 2) * t * p1[i] + 3 * (1 - t) * Math.pow(t, 2) * p2[i] + Math.pow(t, 3) * p3[i];
      };
      ref1 = this.commands;
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        c = ref1[k];
        switch (c.command) {
          case 'moveTo':
          case 'lineTo':
            ref2 = c.args, x = ref2[0], y = ref2[1];
            bbox.addPoint(x, y);
            cx = x;
            cy = y;
            break;
          case 'quadraticCurveTo':
          case 'bezierCurveTo':
            if (c.command === 'quadraticCurveTo') {
              ref3 = c.args, qp1x = ref3[0], qp1y = ref3[1], p3x = ref3[2], p3y = ref3[3];
              cp1x = cx + 2 / 3 * (qp1x - cx);
              cp1y = cy + 2 / 3 * (qp1y - cy);
              cp2x = p3x + 2 / 3 * (qp1x - p3x);
              cp2y = p3y + 2 / 3 * (qp1y - p3y);
            } else {
              ref4 = c.args, cp1x = ref4[0], cp1y = ref4[1], cp2x = ref4[2], cp2y = ref4[3], p3x = ref4[4], p3y = ref4[5];
            }
            bbox.addPoint(p3x, p3y);
            p0 = [cx, cy];
            p1 = [cp1x, cp1y];
            p2 = [cp2x, cp2y];
            p3 = [p3x, p3y];
            for (i = l = 0; l <= 1; i = ++l) {
              b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
              a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
              c = 3 * p1[i] - 3 * p0[i];
              if (a === 0) {
                if (b === 0) {
                  continue;
                }
                t = -c / b;
                if (0 < t && t < 1) {
                  if (i === 0) {
                    bbox.addPoint(f(t), bbox.maxY);
                  }
                  if (i === 1) {
                    bbox.addPoint(bbox.maxX, f(t));
                  }
                }
                continue;
              }
              b2ac = Math.pow(b, 2) - 4 * c * a;
              if (b2ac < 0) {
                continue;
              }
              t1 = (-b + Math.sqrt(b2ac)) / (2 * a);
              if (0 < t1 && t1 < 1) {
                if (i === 0) {
                  bbox.addPoint(f(t1), bbox.maxY);
                }
                if (i === 1) {
                  bbox.addPoint(bbox.maxX, f(t1));
                }
              }
              t2 = (-b - Math.sqrt(b2ac)) / (2 * a);
              if (0 < t2 && t2 < 1) {
                if (i === 0) {
                  bbox.addPoint(f(t2), bbox.maxY);
                }
                if (i === 1) {
                  bbox.addPoint(bbox.maxX, f(t2));
                }
              }
            }
            cx = p3x;
            cy = p3y;
        }
      }
      return this._bbox = Object.freeze(bbox);
    });

    return Path;

  })();

  module.exports = Path;

}).call(this);
