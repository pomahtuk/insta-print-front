// Generated by CoffeeScript 1.9.3
(function() {
  var LookupTable, UnboundedArray, r,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  r = require('restructure');

  UnboundedArray = (function(superClass) {
    var UnboundedArrayAccessor;

    extend(UnboundedArray, superClass);

    function UnboundedArray(type) {
      this.type = type;
      this.length = 0;
    }

    UnboundedArrayAccessor = (function() {
      function UnboundedArrayAccessor(type, stream1, parent1) {
        this.type = type;
        this.stream = stream1;
        this.parent = parent1;
        this.base = this.stream.pos;
        this._items = [];
      }

      UnboundedArrayAccessor.prototype.getItem = function(index) {
        var pos;
        if (this._items[index] == null) {
          pos = this.stream.pos;
          this.stream.pos = this.base + this.type.size(null, this.parent) * index;
          this._items[index] = this.type.decode(this.stream, this.parent);
          this.stream.pos = pos;
        }
        return this._items[index];
      };

      UnboundedArrayAccessor.prototype.inspect = function() {
        return "[UnboundedArray " + this.type.constructor.name + "]";
      };

      return UnboundedArrayAccessor;

    })();

    UnboundedArray.prototype.decode = function(stream, parent) {
      return new UnboundedArrayAccessor(this.type, stream, parent);
    };

    return UnboundedArray;

  })(r.Array);

  exports.UnboundedArray = UnboundedArray;

  exports.LookupTable = LookupTable = function(ValueType) {
    var BinarySearchHeader, LookupSegmentArray, LookupSegmentSingle, LookupSingle, Shadow;
    if (ValueType == null) {
      ValueType = r.uint16;
    }
    Shadow = (function() {
      function Shadow(type) {
        this.type = type;
      }

      Shadow.prototype.decode = function(stream, ctx) {
        ctx = ctx.parent.parent;
        return this.type.decode(stream, ctx);
      };

      Shadow.prototype.size = function(val, ctx) {
        ctx = ctx.parent.parent;
        return this.type.size(val, ctx);
      };

      Shadow.prototype.encode = function(stream, val, ctx) {
        ctx = ctx.parent.parent;
        return this.type.encode(stream, val, ctx);
      };

      return Shadow;

    })();
    ValueType = new Shadow(ValueType);
    BinarySearchHeader = new r.Struct({
      unitSize: r.uint16,
      nUnits: r.uint16,
      searchRange: r.uint16,
      entrySelector: r.uint16,
      rangeShift: r.uint16
    });
    LookupSegmentSingle = new r.Struct({
      lastGlyph: r.uint16,
      firstGlyph: r.uint16,
      value: ValueType
    });
    LookupSegmentArray = new r.Struct({
      lastGlyph: r.uint16,
      firstGlyph: r.uint16,
      values: new r.Pointer(r.uint16, new r.Array(ValueType, function() {
        return this.lastGlyph - this.firstGlyph + 1;
      }), {
        type: 'parent'
      })
    });
    LookupSingle = new r.Struct({
      glyph: r.uint16,
      value: ValueType
    });
    return new r.VersionedStruct(r.uint16, {
      0: {
        values: new UnboundedArray(ValueType)
      },
      2: {
        binarySearchHeader: BinarySearchHeader,
        segments: new r.Array(LookupSegmentSingle, function() {
          return this.binarySearchHeader.nUnits;
        })
      },
      4: {
        binarySearchHeader: BinarySearchHeader,
        segments: new r.Array(LookupSegmentArray, function() {
          return this.binarySearchHeader.nUnits;
        })
      },
      6: {
        binarySearchHeader: BinarySearchHeader,
        segments: new r.Array(LookupSingle, function() {
          return this.binarySearchHeader.nUnits;
        })
      },
      8: {
        firstGlyph: r.uint16,
        count: r.uint16,
        values: new r.Array(ValueType, 'count')
      }
    });
  };

  exports.StateTable = function(entryData, lookupType) {
    var Entry, StateArray, StateHeader, entry, key, val;
    if (entryData == null) {
      entryData = {};
    }
    if (lookupType == null) {
      lookupType = r.uint16;
    }
    entry = {
      newState: r.uint16,
      flags: r.uint16
    };
    for (key in entryData) {
      val = entryData[key];
      entry[key] = val;
    }
    Entry = new r.Struct(entry);
    StateArray = new UnboundedArray(new r.Array(r.uint16, function() {
      return this.nClasses;
    }));
    StateHeader = new r.Struct({
      nClasses: r.uint32,
      classTable: new r.Pointer(r.uint32, new LookupTable(lookupType)),
      stateArray: new r.Pointer(r.uint32, StateArray),
      entryTable: new r.Pointer(r.uint32, new UnboundedArray(Entry))
    });
    return StateHeader;
  };

  exports.StateTable1 = function(entryData, lookupType) {
    var ClassLookupTable, Entry, StateArray, StateHeader1, entry, key, val;
    if (entryData == null) {
      entryData = {};
    }
    if (lookupType == null) {
      lookupType = r.uint16;
    }
    ClassLookupTable = new r.Struct({
      version: function() {
        return 8;
      },
      firstGlyph: r.uint16,
      values: new r.Array(r.uint8, r.uint16)
    });
    entry = {
      newStateOffset: r.uint16,
      newState: function() {
        return (this.newStateOffset - (this.parent.stateArray.base - this.parent._startOffset)) / this.parent.nClasses;
      },
      flags: r.uint16
    };
    for (key in entryData) {
      val = entryData[key];
      entry[key] = val;
    }
    Entry = new r.Struct(entry);
    StateArray = new UnboundedArray(new r.Array(r.uint8, function() {
      return this.nClasses;
    }));
    StateHeader1 = new r.Struct({
      nClasses: r.uint16,
      classTable: new r.Pointer(r.uint16, ClassLookupTable),
      stateArray: new r.Pointer(r.uint16, StateArray),
      entryTable: new r.Pointer(r.uint16, new UnboundedArray(Entry))
    });
    return StateHeader1;
  };

}).call(this);
