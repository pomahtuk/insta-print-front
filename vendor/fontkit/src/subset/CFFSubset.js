// Generated by CoffeeScript 1.9.3
(function() {
  var CFFPrivateDict, CFFSubset, CFFTop, Subset, standardStrings,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Subset = require('./Subset');

  CFFTop = require('../cff/CFFTop');

  CFFPrivateDict = require('../cff/CFFPrivateDict');

  standardStrings = require('../cff/CFFStandardStrings');

  CFFSubset = (function(superClass) {
    var shallowCopy;

    extend(CFFSubset, superClass);

    function CFFSubset() {
      CFFSubset.__super__.constructor.apply(this, arguments);
      this.cff = this.font['CFF '];
      if (!this.cff) {
        throw new Error('Not a CFF Font');
      }
    }

    CFFSubset.prototype.subsetCharstrings = function() {
      var gid, glyph, gsubrs, j, len, path, ref, subr;
      this.charstrings = [];
      gsubrs = {};
      ref = this.glyphs;
      for (j = 0, len = ref.length; j < len; j++) {
        gid = ref[j];
        this.charstrings.push(this.cff.getCharString(gid));
        glyph = this.font.getGlyph(gid);
        path = glyph.path;
        for (subr in glyph._usedGsubrs) {
          gsubrs[subr] = true;
        }
      }
      return this.gsubrs = this.subsetSubrs(this.cff.globalSubrIndex, gsubrs);
    };

    CFFSubset.prototype.subsetSubrs = function(subrs, used) {
      var i, j, len, res, subr;
      res = [];
      for (i = j = 0, len = subrs.length; j < len; i = ++j) {
        subr = subrs[i];
        if (used[i]) {
          this.cff.stream.pos = subr.offset;
          res.push(this.cff.stream.readBuffer(subr.length));
        } else {
          res.push(new Buffer([11]));
        }
      }
      return res;
    };

    shallowCopy = function(obj) {
      var key, res, val;
      res = {};
      for (key in obj) {
        val = obj[key];
        res[key] = val;
      }
      return res;
    };

    CFFSubset.prototype.subsetFontdict = function(topDict) {
      var dict, fd, gid, glyph, i, j, k, len, len1, path, ref, ref1, ref2, subr, used_fds, used_subrs;
      topDict.FDArray = [];
      topDict.FDSelect = {
        version: 0,
        fds: []
      };
      used_fds = {};
      used_subrs = [];
      ref = this.glyphs;
      for (j = 0, len = ref.length; j < len; j++) {
        gid = ref[j];
        fd = this.cff.fdForGlyph(gid);
        if (fd == null) {
          continue;
        }
        if (!used_fds[fd]) {
          topDict.FDArray.push(shallowCopy(this.cff.topDict.FDArray[fd]));
          used_subrs.push({});
        }
        used_fds[fd] = true;
        topDict.FDSelect.fds.push(topDict.FDArray.length - 1);
        glyph = this.font.getGlyph(gid);
        path = glyph.path;
        for (subr in glyph._usedSubrs) {
          used_subrs[used_subrs.length - 1][subr] = true;
        }
      }
      ref1 = topDict.FDArray;
      for (i = k = 0, len1 = ref1.length; k < len1; i = ++k) {
        dict = ref1[i];
        delete dict.FontName;
        if ((ref2 = dict.Private) != null ? ref2.Subrs : void 0) {
          dict.Private = shallowCopy(dict.Private);
          dict.Private.Subrs = this.subsetSubrs(dict.Private.Subrs, used_subrs[i]);
        }
      }
    };

    CFFSubset.prototype.createCIDFontdict = function(topDict) {
      var gid, glyph, j, len, path, privateDict, ref, subr, used_subrs;
      used_subrs = {};
      ref = this.glyphs;
      for (j = 0, len = ref.length; j < len; j++) {
        gid = ref[j];
        glyph = this.font.getGlyph(gid);
        path = glyph.path;
        for (subr in glyph._usedSubrs) {
          used_subrs[subr] = true;
        }
      }
      privateDict = shallowCopy(this.cff.topDict.Private);
      privateDict.Subrs = this.subsetSubrs(this.cff.topDict.Private.Subrs, used_subrs);
      topDict.FDArray = [
        {
          Private: privateDict
        }
      ];
      return topDict.FDSelect = {
        version: 3,
        nRanges: 1,
        ranges: [
          {
            first: 0,
            fd: 0
          }
        ],
        sentinel: this.charstrings.length
      };
    };

    CFFSubset.prototype.addString = function(string) {
      if (!string) {
        return null;
      }
      if (this.strings == null) {
        this.strings = [];
      }
      this.strings.push(string);
      return standardStrings.length + this.strings.length - 1;
    };

    CFFSubset.prototype.encode = function(stream) {
      var charset, j, key, len, ref, top, topDict;
      this.subsetCharstrings();
      charset = {
        version: this.charstrings.length > 255 ? 2 : 1,
        ranges: [
          {
            first: 1,
            nLeft: this.charstrings.length - 2
          }
        ]
      };
      topDict = shallowCopy(this.cff.topDict);
      topDict.Private = null;
      topDict.charset = charset;
      topDict.Encoding = null;
      topDict.CharStrings = this.charstrings;
      ref = ['version', 'Notice', 'Copyright', 'FullName', 'FamilyName', 'Weight', 'PostScript', 'BaseFontName', 'FontName'];
      for (j = 0, len = ref.length; j < len; j++) {
        key = ref[j];
        topDict[key] = this.addString(this.cff.string(topDict[key]));
      }
      topDict.ROS = [this.addString('Adobe'), this.addString('Identity'), 0];
      topDict.CIDCount = this.charstrings.length;
      if (this.cff.isCIDFont) {
        this.subsetFontdict(topDict);
      } else {
        this.createCIDFontdict(topDict);
      }
      top = {
        header: this.cff.header,
        nameIndex: [this.cff.postscriptName],
        topDictIndex: [topDict],
        stringIndex: this.strings,
        globalSubrIndex: this.gsubrs
      };
      return CFFTop.encode(stream, top);
    };

    return CFFSubset;

  })(Subset);

  module.exports = CFFSubset;

}).call(this);
