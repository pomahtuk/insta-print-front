// Generated by CoffeeScript 1.9.3
(function() {
  var AATFeatureMap, AATMorxProcessor, GPOSProcessor, GSUBProcessor, GlyphInfo, GlyphRun, KernProcessor, LayoutEngine, Script, Shapers, UnicodeLayoutEngine, unicode,
    slice = [].slice;

  GSUBProcessor = require('../opentype/GSUBProcessor');

  GPOSProcessor = require('../opentype/GPOSProcessor');

  GlyphInfo = require('../opentype/GlyphInfo');

  Shapers = require('../opentype/shapers');

  AATFeatureMap = require('../aat/AATFeatureMap');

  AATMorxProcessor = require('../aat/AATMorxProcessor');

  KernProcessor = require('./KernProcessor');

  UnicodeLayoutEngine = require('./UnicodeLayoutEngine');

  GlyphRun = require('./GlyphRun');

  Script = require('./Script');

  unicode = require('unicode-properties');

  LayoutEngine = (function() {
    var GlyphPosition;

    function LayoutEngine(font) {
      this.font = font;
    }

    LayoutEngine.prototype.layout = function(string, features, script, language) {
      var codePoints, feature, featureMap, glyph, glyphs, i, j, k, len, len1, positions, shaper;
      if (features == null) {
        features = [];
      }
      if (typeof features === 'string') {
        script = features;
        language = script;
        features = [];
      }
      if (typeof string === 'string') {
        if (script == null) {
          script = Script.forString(string);
        }
        glyphs = this.font.glyphsForString(string);
      } else {
        if (script == null) {
          codePoints = [];
          for (j = 0, len = string.length; j < len; j++) {
            glyph = string[j];
            codePoints.push.apply(codePoints, glyph.codePoints);
          }
          script = Script.forCodePoints(codePoints);
        }
        glyphs = string;
      }
      if (glyphs.length === 0) {
        return new GlyphRun(glyphs, []);
      }
      if (!this.font.morx && (this.font.GSUB || this.font.GPOS)) {
        shaper = Shapers.choose(script);
        features.push.apply(features, shaper.getGlobalFeatures(script));
        glyphs = (function() {
          var k, len1, results;
          results = [];
          for (i = k = 0, len1 = glyphs.length; k < len1; i = ++k) {
            glyph = glyphs[i];
            results.push(new GlyphInfo(glyph.id, slice.call(glyph.codePoints), features));
          }
          return results;
        })();
        features.push.apply(features, shaper.assignFeatures(glyphs, script, this.font));
      }
      featureMap = {};
      for (k = 0, len1 = features.length; k < len1; k++) {
        feature = features[k];
        featureMap[feature] = true;
      }
      features = Object.keys(featureMap);
      glyphs = this.substitute(glyphs, features, script);
      positions = this.position(glyphs, features, script);
      return new GlyphRun(glyphs, positions);
    };

    LayoutEngine.prototype.substitute = function(glyphs, features, script, language) {
      var isRTL;
      if (this.font.morx) {
        isRTL = Script.direction(script) === 'rtl';
        if (isRTL) {
          glyphs.reverse();
        }
        if (this.morxProcessor == null) {
          this.morxProcessor = new AATMorxProcessor(this.font);
        }
        this.morxProcessor.process(glyphs, AATFeatureMap.mapOTToAAT(features));
        if (isRTL && this.font.GPOS) {
          glyphs.reverse();
        }
      } else if (this.font.GSUB) {
        if (this.GSUBProcessor == null) {
          this.GSUBProcessor = new GSUBProcessor(this.font, this.font.GSUB);
        }
        this.GSUBProcessor.selectScript(script, language);
        this.GSUBProcessor.applyFeatures(features, glyphs);
      }
      return glyphs;
    };

    GlyphPosition = (function() {
      function GlyphPosition(xAdvance, yAdvance, xOffset, yOffset) {
        this.xAdvance = xAdvance != null ? xAdvance : 0;
        this.yAdvance = yAdvance != null ? yAdvance : 0;
        this.xOffset = xOffset != null ? xOffset : 0;
        this.yOffset = yOffset != null ? yOffset : 0;
      }

      return GlyphPosition;

    })();

    LayoutEngine.prototype.position = function(glyphs, features, script, language) {
      var glyph, gposFeatures, i, j, k, len, len1, positions, realGlyph, realGlyphs, ref;
      realGlyphs = (function() {
        var j, len, results;
        if (this.font.GPOS || this.font.GSUB) {
          results = [];
          for (i = j = 0, len = glyphs.length; j < len; i = ++j) {
            glyph = glyphs[i];
            results.push(this.font.getGlyph(glyph.id, glyph.codePoints));
          }
          return results;
        } else {
          return glyphs;
        }
      }).call(this);
      positions = [];
      for (i = j = 0, len = glyphs.length; j < len; i = ++j) {
        glyph = glyphs[i];
        positions.push(new GlyphPosition(realGlyphs[i].advanceWidth));
      }
      if (this.font.GPOS) {
        if (this.GPOSProcessor == null) {
          this.GPOSProcessor = new GPOSProcessor(this.font, this.font.GPOS);
        }
        this.GPOSProcessor.selectScript(script, language);
        this.GPOSProcessor.applyFeatures(features, glyphs, positions);
      }
      if (this.font.GPOS || this.font.GSUB) {
        for (i = k = 0, len1 = realGlyphs.length; k < len1; i = ++k) {
          realGlyph = realGlyphs[i];
          glyphs[i] = realGlyph;
        }
        if (Script.direction(script) === 'rtl') {
          glyphs.reverse();
          positions.reverse();
        }
      }
      gposFeatures = ((ref = this.GPOSProcessor) != null ? ref.features : void 0) || {};
      if (!this.font.GPOS) {
        if (this.unicodeLayoutEngine == null) {
          this.unicodeLayoutEngine = new UnicodeLayoutEngine(this.font);
        }
        this.unicodeLayoutEngine.positionGlyphs(glyphs, positions);
      }
      if (!('kern' in gposFeatures) && this.font.kern) {
        if (this.kernProcessor == null) {
          this.kernProcessor = new KernProcessor(this.font);
        }
        this.kernProcessor.process(glyphs, positions);
      }
      return positions;
    };

    LayoutEngine.prototype.getAvailableFeatures = function(script, language) {
      var aatFeatures, features;
      features = [];
      if (this.font.GSUB) {
        if (this.GSUBProcessor == null) {
          this.GSUBProcessor = new GSUBProcessor(this.font, this.font.GSUB);
        }
        this.GSUBProcessor.selectScript(script, language);
        features.push.apply(features, Object.keys(this.GSUBProcessor.features));
      }
      if (this.font.GPOS) {
        if (this.GPOSProcessor == null) {
          this.GPOSProcessor = new GPOSProcessor(this.font, this.font.GPOS);
        }
        this.GPOSProcessor.selectScript(script, language);
        features.push.apply(features, Object.keys(this.GPOSProcessor.features));
      }
      if (this.font.morx) {
        if (this.morxProcessor == null) {
          this.morxProcessor = new AATMorxProcessor(this.font);
        }
        aatFeatures = AATFeatureMap.mapAATToOT(this.morxProcessor.getSupportedFeatures());
        features.push.apply(features, aatFeatures);
      }
      if (this.font.kern && (!this.font.GPOS || !('kern' in this.GPOSProcessor.features))) {
        features.push('kern');
      }
      return features;
    };

    return LayoutEngine;

  })();

  module.exports = LayoutEngine;

}).call(this);
