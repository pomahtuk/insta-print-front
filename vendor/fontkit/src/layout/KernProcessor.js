// Generated by CoffeeScript 1.9.3
(function() {
  var KernProcessor;

  KernProcessor = (function() {
    function KernProcessor(font) {
      this.font = font;
      this.kern = this.font.kern;
    }

    KernProcessor.prototype.process = function(glyphs, positions) {
      var glyph, glyphIndex, i, left, len, results, right;
      results = [];
      for (glyphIndex = i = 0, len = glyphs.length; i < len; glyphIndex = ++i) {
        glyph = glyphs[glyphIndex];
        if (glyphIndex + 1 >= glyphs.length) {
          break;
        }
        left = glyphs[glyphIndex].id;
        right = glyphs[glyphIndex + 1].id;
        results.push(positions[glyphIndex].xAdvance += this.getKerning(left, right));
      }
      return results;
    };

    KernProcessor.prototype.getKerning = function(left, right) {
      var i, index, j, leftOffset, len, len1, pair, ref, ref1, res, rightOffset, s, table, val;
      res = 0;
      ref = this.kern.tables;
      for (i = 0, len = ref.length; i < len; i++) {
        table = ref[i];
        if (table.coverage.crossStream) {
          continue;
        }
        switch (table.version) {
          case 0:
            if (!table.coverage.horizontal) {
              continue;
            }
            break;
          case 1:
            if (table.coverage.vertical || table.coverage.variation) {
              continue;
            }
            break;
          default:
            throw new Error("Unsupported kerning table version " + table.version);
        }
        val = 0;
        s = table.subtable;
        switch (table.format) {
          case 0:
            ref1 = s.pairs;
            for (j = 0, len1 = ref1.length; j < len1; j++) {
              pair = ref1[j];
              if (pair.left === left && pair.right === right) {
                val = pair.value;
                break;
              }
            }
            break;
          case 2:
            if (left >= s.leftTable.firstGlyph && left < s.leftTable.firstGlyph + s.leftTable.nGlyphs) {
              leftOffset = s.leftTable.offsets[left - s.leftTable.firstGlyph];
            } else {
              leftOffset = s.array.off;
            }
            if (right >= s.rightTable.firstGlyph && right < s.rightTable.firstGlyph + s.rightTable.nGlyphs) {
              rightOffset = s.rightTable.offsets[right - s.rightTable.firstGlyph];
            } else {
              rightOffset = 0;
            }
            index = (leftOffset + rightOffset - s.array.off) / 2;
            val = s.array.values.get(index);
            break;
          case 3:
            if (left >= s.glyphCount || right >= s.glyphCount) {
              return 0;
            }
            val = s.kernValue[s.kernIndex[s.leftClass[left] * s.rightClassCount + s.rightClass[right]]];
            break;
          default:
            throw new Error("Unsupported kerning sub-table format " + table.format);
        }
        if (table.coverage.override) {
          res = val;
        } else {
          res += val;
        }
      }
      return res;
    };

    return KernProcessor;

  })();

  module.exports = KernProcessor;

}).call(this);
