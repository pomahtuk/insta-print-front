// Generated by CoffeeScript 1.9.3
(function() {
  var BBox, CFFGlyph, CFFSubset, COLRGlyph, CmapProcessor, Directory, GlyphVariationProcessor, LayoutEngine, SBIXGlyph, TTFFont, TTFGlyph, TTFSubset, r, tables;

  r = require('restructure');

  Directory = require('./tables/directory');

  tables = require('./tables');

  CmapProcessor = require('./CmapProcessor');

  LayoutEngine = require('./layout/LayoutEngine');

  TTFGlyph = require('./glyph/TTFGlyph');

  CFFGlyph = require('./glyph/CFFGlyph');

  SBIXGlyph = require('./glyph/SBIXGlyph');

  COLRGlyph = require('./glyph/COLRGlyph');

  GlyphVariationProcessor = require('./glyph/GlyphVariationProcessor');

  TTFSubset = require('./subset/TTFSubset');

  CFFSubset = require('./subset/CFFSubset');

  BBox = require('./glyph/BBox');

  TTFFont = (function() {
    var get, getTable;

    get = require('./get')(TTFFont);

    TTFFont.probe = function(buffer) {
      var ref;
      return (ref = buffer.toString('ascii', 0, 4)) === 'true' || ref === 'OTTO' || ref === String.fromCharCode(0, 1, 0, 0);
    };

    function TTFFont(stream1, variationCoords) {
      var ref, table, tag;
      this.stream = stream1;
      if (variationCoords == null) {
        variationCoords = null;
      }
      this._tables = {};
      this._glyphs = {};
      this._decodeDirectory();
      ref = this.directory.tables;
      for (tag in ref) {
        table = ref[tag];
        if (tables[tag]) {
          Object.defineProperty(this, tag, {
            get: getTable.bind(this, table)
          });
        }
      }
      if (variationCoords) {
        this._variationProcessor = new GlyphVariationProcessor(this, variationCoords);
      }
    }

    getTable = function(table) {
      var pos;
      if (!(table.tag in this._tables)) {
        pos = this.stream.pos;
        this.stream.pos = table.offset;
        this._tables[table.tag] = this._decodeTable(table);
        this.stream.pos = pos;
      }
      return this._tables[table.tag];
    };

    TTFFont.prototype._getTableStream = function(tag) {
      var table;
      table = this.directory.tables[tag];
      if (table) {
        this.stream.pos = table.offset;
        return this.stream;
      }
      return null;
    };

    TTFFont.prototype._decodeDirectory = function() {
      this._directoryPos = this.stream.pos;
      return this.directory = Directory.decode(this.stream, {
        _startOffset: 0
      });
    };

    TTFFont.prototype._decodeTable = function(table) {
      return tables[table.tag].decode(this.stream, this, table.length);
    };

    get('postscriptName', function() {
      var lang, name;
      name = this.name.records.postscriptName;
      lang = Object.keys(name)[0];
      return name[lang];
    });

    get('fullName', function() {
      var ref;
      return (ref = this.name.records.fullName) != null ? ref.English : void 0;
    });

    get('familyName', function() {
      var ref;
      return (ref = this.name.records.fontFamily) != null ? ref.English : void 0;
    });

    get('subfamilyName', function() {
      var ref;
      return (ref = this.name.records.fontSubfamily) != null ? ref.English : void 0;
    });

    get('copyright', function() {
      var ref;
      return (ref = this.name.records.copyright) != null ? ref.English : void 0;
    });

    get('version', function() {
      var ref;
      return (ref = this.name.records.version) != null ? ref.English : void 0;
    });

    get('ascent', function() {
      return this.hhea.ascent;
    });

    get('descent', function() {
      return this.hhea.descent;
    });

    get('lineGap', function() {
      return this.hhea.lineGap;
    });

    get('underlinePosition', function() {
      return this.post.underlinePosition;
    });

    get('underlineThickness', function() {
      return this.post.underlineThickness;
    });

    get('italicAngle', function() {
      return this.post.italicAngle;
    });

    get('capHeight', function() {
      var ref;
      return ((ref = this['OS/2']) != null ? ref.capHeight : void 0) || this.ascent;
    });

    get('xHeight', function() {
      var ref;
      return ((ref = this['OS/2']) != null ? ref.xHeight : void 0) || 0;
    });

    get('numGlyphs', function() {
      return this.maxp.numGlyphs;
    });

    get('unitsPerEm', function() {
      return this.head.unitsPerEm;
    });

    get('bbox', function() {
      return this._bbox != null ? this._bbox : this._bbox = Object.freeze(new BBox(this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax));
    });

    get('characterSet', function() {
      if (this._cmapProcessor == null) {
        this._cmapProcessor = new CmapProcessor(this.cmap);
      }
      return this._cmapProcessor.getCharacterSet();
    });

    TTFFont.prototype.hasGlyphForCodePoint = function(codePoint) {
      if (this._cmapProcessor == null) {
        this._cmapProcessor = new CmapProcessor(this.cmap);
      }
      return !!this._cmapProcessor.lookup(codePoint);
    };

    TTFFont.prototype.glyphForCodePoint = function(codePoint) {
      if (this._cmapProcessor == null) {
        this._cmapProcessor = new CmapProcessor(this.cmap);
      }
      return this.getGlyph(this._cmapProcessor.lookup(codePoint), [codePoint]);
    };

    TTFFont.prototype.glyphsForString = function(string) {
      var code, glyphs, idx, len, next;
      glyphs = [];
      len = string.length;
      idx = 0;
      while (idx < len) {
        code = string.charCodeAt(idx++);
        if ((0xd800 <= code && code <= 0xdbff) && idx < len) {
          next = string.charCodeAt(idx);
          if ((0xdc00 <= next && next <= 0xdfff)) {
            idx++;
            code = ((code & 0x3FF) << 10) + (next & 0x3FF) + 0x10000;
          }
        }
        glyphs.push(this.glyphForCodePoint(code));
      }
      return glyphs;
    };

    TTFFont.prototype.layout = function(string, userFeatures, script, language) {
      if (this._layoutEngine == null) {
        this._layoutEngine = new LayoutEngine(this);
      }
      return this._layoutEngine.layout(string, userFeatures, script, language);
    };

    get('availableFeatures', function() {
      if (this._layoutEngine == null) {
        this._layoutEngine = new LayoutEngine(this);
      }
      return this._layoutEngine.getAvailableFeatures();
    });

    TTFFont.prototype.widthOfString = function(string, features, script, language) {
      if (this._layoutEngine == null) {
        this._layoutEngine = new LayoutEngine(this);
      }
      return this._layoutEngine.layout(string, features, script, language).advanceWidth;
    };

    TTFFont.prototype._getBaseGlyph = function(glyph, characters) {
      if (characters == null) {
        characters = [];
      }
      if (!this._glyphs[glyph]) {
        if (this.directory.tables.glyf != null) {
          this._glyphs[glyph] = new TTFGlyph(glyph, characters, this);
        } else if (this.directory.tables['CFF '] != null) {
          this._glyphs[glyph] = new CFFGlyph(glyph, characters, this);
        }
      }
      return this._glyphs[glyph] || null;
    };

    TTFFont.prototype.getGlyph = function(glyph, characters) {
      if (characters == null) {
        characters = [];
      }
      if (!this._glyphs[glyph]) {
        if (this.directory.tables.sbix != null) {
          this._glyphs[glyph] = new SBIXGlyph(glyph, characters, this);
        } else if ((this.directory.tables.COLR != null) && (this.directory.tables.CPAL != null)) {
          this._glyphs[glyph] = new COLRGlyph(glyph, characters, this);
        } else {
          this._getBaseGlyph(glyph, characters);
        }
      }
      return this._glyphs[glyph] || null;
    };

    TTFFont.prototype.createSubset = function() {
      if (this.directory.tables['CFF '] != null) {
        return new CFFSubset(this);
      }
      return new TTFSubset(this);
    };

    get('variationAxes', function() {
      var axis, j, len1, ref, res;
      res = {};
      if (!this.fvar) {
        return res;
      }
      ref = this.fvar.axis;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        axis = ref[j];
        res[axis.axisTag] = {
          name: axis.name,
          min: axis.minValue,
          "default": axis.defaultValue,
          max: axis.maxValue
        };
      }
      return res;
    });

    get('namedVariations', function() {
      var axis, i, instance, j, k, len1, len2, ref, ref1, res, settings;
      res = {};
      if (!this.fvar) {
        return res;
      }
      ref = this.fvar.instance;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        instance = ref[j];
        settings = {};
        ref1 = this.fvar.axis;
        for (i = k = 0, len2 = ref1.length; k < len2; i = ++k) {
          axis = ref1[i];
          settings[axis.axisTag] = instance.coord[i];
        }
        res[instance.name] = settings;
      }
      return res;
    });

    TTFFont.prototype.getVariation = function(settings) {
      var axis, coords, font, i, stream;
      if (!(this.directory.tables.fvar && this.directory.tables.gvar && this.directory.tables.glyf)) {
        throw new Error('Variations require a font with the fvar, gvar, and glyf tables.');
      }
      if (typeof settings === 'string') {
        settings = this.namedVariations[settings];
      }
      if (typeof settings !== 'object') {
        throw new Error('Variation settings must be either a variation name or settings object.');
      }
      coords = (function() {
        var j, len1, ref, results;
        ref = this.fvar.axis;
        results = [];
        for (i = j = 0, len1 = ref.length; j < len1; i = ++j) {
          axis = ref[i];
          if (axis.axisTag in settings) {
            results.push(Math.max(axis.minValue, Math.min(axis.maxValue, settings[axis.axisTag])));
          } else {
            results.push(axis.defaultValue);
          }
        }
        return results;
      }).call(this);
      stream = new r.DecodeStream(this.stream.buffer);
      stream.pos = this._directoryPos;
      font = new TTFFont(stream, coords);
      font._tables = this._tables;
      return font;
    };

    TTFFont.prototype.getFont = function(name) {
      return this.getVariation(name);
    };

    return TTFFont;

  })();

  module.exports = TTFFont;

}).call(this);
